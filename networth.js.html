<script>
/**
 * NetWorthManager - Enhanced Professional Net Worth tracking component with Chart Visualization and Asset Allocation
 * UPDATED: Removed manual change tracking, added auto-calculated changes, improved modal, added remove toggle
 */
var NetWorthManager = (function() {
  // Private variables
  let _initialized = false;
  let _netWorthData = {
    summary: {
      totalNetWorth: 0,
      totalAssets: 0,
      totalDebts: 0,
      previousNetWorth: 0,
      change: 0,
      currentMonth: '',
      currentYear: '',
      previousMonth: '',
      previousYear: ''
    },
    entries: []
  };
  
  // Current viewing month/year
  let _currentMonth = new Date().getMonth();
  let _currentYear = new Date().getFullYear();
  
  // Chart variables
  let _chart = null;
  let _chartTimespan = 'thisyear';
  let _chartMode = 'allocation';
  let _selectedYear = new Date().getFullYear(); // For performance chart year selection
  let _assetNameColors = {}; 
  const VALID_CHART_MODES = ['performance', 'timeline', 'allocation'];
  
  // Remove mode toggle
  let _removeMode = false;

  // Sorting state per category - load from localStorage or default to empty object
  let _categorySort = JSON.parse(localStorage.getItem('nwCategorySort')) || {};
  const DEFAULT_SORT = { column: 'amount', direction: 'desc' };

  function getCategorySort(categoryKey) {
    return _categorySort[categoryKey] || { ...DEFAULT_SORT };
  }

  // Translation helper function
  function getTranslation(key) {
    // Try to use the global translation function if available
    if (typeof window.getTranslation === 'function' && typeof getLanguageFromSettings === 'function') {
      try {
        const lang = getLanguageFromSettings();
        const translated = window.getTranslation(key, lang);
        return translated;
      } catch (e) {
        console.error('Translation error:', e);
      }
    }
    
    // Try direct access to translation objects if loaded
    if (typeof ENGLISH_TRANSLATIONS !== 'undefined' && ENGLISH_TRANSLATIONS[key]) {
      return ENGLISH_TRANSLATIONS[key];
    }
    
    // Fallback to key if translation system not available
    return key;
  }

  function normalizeChartMode(mode) {
    return VALID_CHART_MODES.includes(mode) ? mode : 'allocation';
  }

  function getDefaultChartMode() {
    let mode = 'allocation';

    try {
      if (typeof SimBudget !== 'undefined' &&
          SimBudget.Settings &&
          typeof SimBudget.Settings.getSetting === 'function') {
        const setting = SimBudget.Settings.getSetting('netWorthDefaultChart');
        if (setting) {
          mode = setting;
        }
      } else if (typeof CacheManager !== 'undefined' &&
                 CacheManager &&
                 typeof CacheManager.getSettings === 'function') {
        const cachedSettings = CacheManager.getSettings();
        if (cachedSettings && cachedSettings.netWorthDefaultChart) {
          mode = cachedSettings.netWorthDefaultChart;
        }
      }
    } catch (error) {
      console.warn('NetWorthManager: unable to determine default chart mode', error);
    }

    return normalizeChartMode(mode);
  }
  
  // Hardcoded asset categories
  
  const ASSET_CATEGORIES = {
    'Liquid Assets': {
      name: 'Liquid Assets | Accounts',
      singularName: 'Liquid Asset',
      isDebt: false,
      suggestedTypes: [
        'Cash',
        'Bank Account',
        'Checking Account', 
        'Savings Account',
        'Current Account',
        'Giro Account',
        'Transaction Account',
        'Emergency Fund',
        'Money Market',
        'Certificate of Deposit',
        'Term Deposit',
        'Fixed Deposit',
        'High-Yield Savings',
        'Digital Wallet',
        'E-Wallet',
        'Mobile Money',
        'Payment App Balance',
        'Prepaid Account',
        'Virtual Bank Account',
        'Multi-Currency Account',
        'Prepaid Cards',
        'Gift Cards',
        'Travel Cards',
        'Foreign Currency',
        'Petty Cash',
        'Business Cash',
        'Safe Deposit',
        'Treasury Bills',
        'Commercial Paper'
      ],
      color: '#3498db'
    },
    'Investments': {
      name: 'Investments',
      singularName: 'Investment',
      isDebt: false,
      suggestedTypes: [
        'Stocks',
        'Bonds',
        'Mutual Funds',
        'ETFs',
        'Index Funds',
        'REITs',
        'Real Estate Crowdfunding',
        'Bitcoin',
        'Ethereum',
        'Cryptocurrency',
        'NFTs',
        'Options',
        'Futures',
        'Forex',
        'Derivatives',
        'Commodities',
        'Gold Investment',
        'Silver Investment',
        'P2P Lending',
        'Crowdfunding',
        'Angel Investment',
        'Venture Capital',
        'Private Equity',
        'Hedge Funds',
        'Unit Trusts',
        'Investment Trusts',
        'ISA (UK)',
        'TFSA (Canada)',
        'Superannuation (Australia)',
        'KiwiSaver (NZ)',
        'Retirement Account',
        'Pension',
        '401k',
        '403b',
        'IRA',
        'Roth IRA',
        'SEP IRA',
        'HSA Investment',
        '529 Plan',
        'RESP (Canada)',
        'PEA (France)',
        'NISA (Japan)',
        'PPR (Portugal)',
        'Riester (Germany)',
        'Pillar 3a (Switzerland)',
        'Life Insurance Cash Value',
        'Annuities',
        'Structured Products',
        'Sukuk (Islamic Bonds)',
        'Shariah Investments'
      ],
      color: '#2ecc71'
    },
    'Physical Assets': {
      name: 'Physical Assets',
      singularName: 'Physical Asset',
      isDebt: false, 
      suggestedTypes: [
        'Primary Residence',
        'Vacation Home',
        'Rental Property',
        'Land',
        'Commercial Property',
        'Real Estate',
        'Car',
        'Motorcycle',
        'Boat',
        'RV/Caravan',
        'Aircraft',
        'Classic Car',
        'Electric Vehicle',
        'Gold Bullion',
        'Silver Bullion',
        'Platinum',
        'Precious Metals',
        'Jewelry',
        'Watches',
        'Diamonds',
        'Art Collection',
        'Paintings',
        'Sculptures',
        'Antiques',
        'Collectibles',
        'Rare Books',
        'Wine Collection',
        'Stamps',
        'Coins',
        'Sports Memorabilia',
        'Musical Instruments',
        'Designer Items',
        'Furniture',
        'Electronics',
        'Home Appliances',
        'Computer Equipment',
        'Camera Equipment',
        'Tools',
        'Machinery',
        'Farm Equipment',
        'Livestock',
        'Horses',
        'Solar Panels',
        'Business Equipment',
        'Inventory',
        'Patents',
        'Trademarks',
        'Domain Names'
      ],
      color: '#f39c12'
    },
    'Debts': {
      name: 'Debts',
      singularName: 'Debt',
      isDebt: true,
      suggestedTypes: [
        'Mortgage',
        'Home Equity Loan',
        'HELOC',
        'Second Mortgage',
        'Reverse Mortgage',
        'Car Loan',
        'Auto Lease',
        'Motorcycle Loan',
        'Boat Loan',
        'RV Loan',
        'Personal Loan',
        'Credit Card',
        'Store Credit Card',
        'Charge Card',
        'Student Loan',
        'Parent PLUS Loan',
        'Private Student Loan',
        'Medical Debt',
        'Dental Loan',
        'Payday Loan',
        'Title Loan',
        'Pawn Shop Loan',
        'Business Loan',
        'SBA Loan',
        'Equipment Financing',
        'Invoice Financing',
        'Merchant Cash Advance',
        'Tax Debt',
        'IRS Payment Plan',
        'State Tax Debt',
        'Property Tax Debt',
        'Family Loan',
        'Friend Loan',
        'Overdraft',
        'Bank Line of Credit',
        'Margin Loan',
        'Securities Loan',
        'Crypto Loan',
        'DeFi Loan',
        'Microfinance Loan',
        'Peer-to-Peer Loan',
        'Consolidation Loan',
        'Bridge Loan',
        'Hard Money Loan',
        'Construction Loan',
        'Land Loan',
        'Vacation Loan',
        'Wedding Loan',
        'Legal Fees Owed',
        'Child Support',
        'Alimony',
        'Buy Now Pay Later',
        'Installment Plan',
        'Deferred Payment'
      ],
      color: '#e74c3c'
    }
  };
  
  // FIX BUG 1: Updated color palette with exact colors provided
  const ASSET_TYPE_COLORS_PALETTE = [
  '#F8CBA8', '#FF6F61', '#FFD166', '#06D6A0', '#00FFBF', '#ffc6ff',
   '#2ECC71', '#83D0C9', '#38A3A5', '#F08080', 
  '#FFB74D', '#FFD54F', '#4FC3F7', '#4DD0E1', '#81C784', '#A5D6A7',
  '#FF8A65', '#FFCC80', '#BA68C8', '#CE93D8', '#FFF176', '#FFEB3B'
 ];
  
  // Asset type to color mapping (will be dynamically assigned)
  let ASSET_TYPE_COLORS = {};
  
  // DOM element cache
  const _elements = {};
  
  function getElement(id) {
    if (!_elements[id]) {
      _elements[id] = document.getElementById(id);
    }
    return _elements[id];
  }
  
  // Rollover protection flag
  let _autoRolloverCompleted = false;
  

/**
 * Initialize the Net Worth Manager
 */
function init(containerId, cachedData) {
  const container = containerId ? document.getElementById(containerId) : document.getElementById('netWorthContent');
  
  if (!container) {
    console.error('NetWorthManager: Container element not found');
    return;
  }
  
  _elements['netWorthContent'] = container;
  _chartMode = getDefaultChartMode();
  
  // Process whatever data we receive
  if (cachedData && Array.isArray(cachedData) && cachedData.length > 0) {
    _netWorthData = {
      entries: cachedData,
      summary: {
        totalNetWorth: 0,
        totalAssets: 0,
        totalDebts: 0,
        change: 0
      }
    };

    // Process the data
    processNetWorthData(cachedData);
  } else {
    // Show empty state or loading
    showLoadingState();
    fetchFreshNetWorthData();
  }
  
  initializeMonthNavigation();
  _initialized = true;
}
  
  function showLoadingState() {
    // Update the top bar indicator instead of showing overlay
    const refreshElement = document.getElementById('lastRefreshTimeNetWorth');
    const refreshBtn = document.getElementById('refreshNetWorth');
    
    if (refreshElement) {
      refreshElement.textContent = 'Loading...';
      refreshElement.style.color = '#f39c12';
      refreshElement.style.fontWeight = 'bold';
    }
    
    if (refreshBtn) {
      refreshBtn.classList.add('loading');
    }
    
    // Don't clear the container - keep existing content visible
  }
  
  /**
   * Hide loading indicator
   */
  function hideLoadingIndicator() {
    const refreshElement = document.getElementById('lastRefreshTimeNetWorth');
    const refreshBtn = document.getElementById('refreshNetWorth');
    
    if (refreshBtn) {
      refreshBtn.classList.remove('loading');
    }
    
    // Update last refresh time
    if (refreshElement) {
      const now = new Date();
      const timeString = now.toLocaleTimeString('en-US', { 
        hour: 'numeric', 
        minute: '2-digit',
        hour12: true 
      });
      const updatedAtText = window.getTranslation ? window.getTranslation('updated_at', getLanguageFromSettings()) : 'Updated at';
      refreshElement.textContent = `${updatedAtText} ${timeString}`;
      refreshElement.style.color = '';
      refreshElement.style.fontWeight = '';
    }
  }
  

  

  
  function fetchFreshNetWorthData() {
    if (!window.API || typeof API.getNetWorthData !== 'function') {
      console.error('NetWorthManager: API.getNetWorthData not available');
      showErrorState(getTranslation('api_not_available'));
      return;
    }
    
    API.getNetWorthData(
      function(result) {
        if (result && result.success) {
          
          
          // Validate and clean entries before processing
          const cleanedEntries = (result.entries || []).map(entry => {
            // Ensure all required fields exist
            return {
              ...entry,
              amount: entry.amount !== undefined && entry.amount !== null && entry.amount !== '' 
                ? parseFloat(entry.amount) || 0 
                : 0,
              type: entry.type || '',
              name: entry.name || '',
              asset: entry.asset || '',
              date: entry.date || '',
              notes: entry.notes || ''
            };
          });
          
          processNetWorthData(cleanedEntries);
          
          // Update last refresh time and hide loading indicator
          updateLastRefreshTime();
          hideLoadingIndicator();
          
          if (window.CacheManager && typeof CacheManager.setNetWorthWithTimestamp === 'function') {
            CacheManager.setNetWorthWithTimestamp({ entries: cleanedEntries, goals: result.goals }, result.timestamp);
          }
        } else {
          console.error('NetWorthManager: Invalid server response:', result);
          // Remove loading state from refresh button on error
          const refreshBtn = document.getElementById('refreshNetWorth');
          if (refreshBtn) {
            refreshBtn.classList.remove('loading');
          }
          showErrorState(result ? result.error : getTranslation('invalid_server_response'));
        }
      },
      function(error) {
        console.error('NetWorthManager: Error loading data:', error);
        // Remove loading state from refresh button on error
        const refreshBtn = document.getElementById('refreshNetWorth');
        if (refreshBtn) {
          refreshBtn.classList.remove('loading');
        }
        showErrorState(getTranslation('error_loading_data') + error);
      }
    );
  }
  
  function showErrorState(message) {
    const container = getElement('netWorthContent');
    if (!container) return;
    
    updateBannerNetWorth(null);
    setupSummaryObserver();
    
    // Check if this is a first-time user (no spreadsheet connected)
    if (message && message.includes('No spreadsheet ID found')) {
      if (typeof window.renderNoSpreadsheetWelcome === 'function') {
        window.renderNoSpreadsheetWelcome(container);
      } else {
        container.innerHTML = '<div class="grid-welcome" style="text-align:center;padding:60px 20px;">No spreadsheet connected.</div>';
      }
    } else {
      // Show regular error state for other errors
      container.innerHTML = `
        <div class="nw-error">
          <div class="nw-error-icon">
            <i class="material-icons">error_outline</i>
          </div>
          <h3 data-translate="error_loading_net_worth_data">Error Loading Net Worth Data</h3>
          <p>${message}</p>
          <button onclick="NetWorthManager.refresh()" class="nw-btn nw-btn-primary">
            <i class="material-icons">refresh</i> <span data-translate="try_again">Try Again</span>
          </button>
        </div>
      `;
    }
    
    // Apply translations to the dynamically created error content
    if (window.SimBudget && SimBudget.applyTranslations) {
      SimBudget.applyTranslations();
    }
  }
  
  function processNetWorthData(entries) {
  _netWorthData.entries = entries || [];
  
  // FIX: Assign colors FIRST, before any rendering
  assignColorsToAssetTypes();
  
  checkAutoRollover();
  calculateSummary();
  renderNetWorthView();
}
  
  // FIX BUG 1: Function to assign colors to unique asset types
  function assignColorsToAssetTypes() {
    const uniqueTypes = new Set();
    
    // Collect all unique asset types
    _netWorthData.entries.forEach(entry => {
      if (entry.type) {
        uniqueTypes.add(entry.type);
      }
    });
    
    // Sort types for consistent color assignment
    const sortedTypes = Array.from(uniqueTypes).sort();
    
    // Clear existing colors
    ASSET_TYPE_COLORS = {};
    
    // Assign colors from palette
    sortedTypes.forEach((type, index) => {
      ASSET_TYPE_COLORS[type] = ASSET_TYPE_COLORS_PALETTE[index % ASSET_TYPE_COLORS_PALETTE.length];
    });
    
  }
  
  function assignColorsToAssetNames(assets) {
    // Get all unique asset names that need colors
    const needsColor = assets.filter(asset => !_assetNameColors[asset.name]);
    
    // Get already used colors
    const usedColors = new Set(Object.values(_assetNameColors));
    
    // Find available colors
    const availableColors = ASSET_TYPE_COLORS_PALETTE.filter(color => !usedColors.has(color));
    
    // Assign colors
    needsColor.forEach((asset, index) => {
      if (availableColors[index]) {
        _assetNameColors[asset.name] = availableColors[index];
      } else {
        // If we run out of unique colors, start reusing from the beginning
        _assetNameColors[asset.name] = ASSET_TYPE_COLORS_PALETTE[index % ASSET_TYPE_COLORS_PALETTE.length];
      }
    });
  }
  
  function checkAutoRollover() {
    if (_autoRolloverCompleted) {
      return;
    }
    
    const realNow = new Date();
    
    if (_currentMonth !== realNow.getMonth() || _currentYear !== realNow.getFullYear()) {
      return;
    }
    
    const currentMonthEntries = getCurrentMonthEntries();
    if (currentMonthEntries.length > 0) {
      _autoRolloverCompleted = true;
      return;
    }
    
    const previousMonthEntries = getPreviousMonthEntries();
    if (previousMonthEntries.length === 0) {
      _autoRolloverCompleted = true;
      return;
    }
    
    _autoRolloverCompleted = true;
    
    const uniqueEntries = {};
    previousMonthEntries.forEach(entry => {
      const key = `${entry.asset}|${entry.name}`;
      uniqueEntries[key] = entry;
    });
    
    const newEntries = Object.values(uniqueEntries).map((entry, index) => {
      const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                         'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      const currentMonthDate = `${monthNames[_currentMonth]} ${_currentYear}`;
      return {
        ...entry,
        date: currentMonthDate,
        id: `rollover-${_currentYear}-${_currentMonth}-${Date.now()}-${index}`,
        notes: entry.notes || '',
        // Ensure amount is a valid number
        amount: entry.amount !== undefined && entry.amount !== null && entry.amount !== '' 
          ? parseFloat(entry.amount) || 0 
          : 0
      };
    });
    
    
    _netWorthData.entries = _netWorthData.entries.concat(newEntries);
    saveNetWorthEntries(newEntries);
    
    // Immediately update the UI to show the copied data
    renderNetWorthView();
    bindEventHandlers();
    
    setTimeout(() => {
      showMessage(Utils.translateCategory('automatically_copied_assets').replace('{count}', newEntries.length).replace('{prevMonthName}', getPreviousMonthName()), 'success');
    }, 1000);
  }
  
  function calculateSummary() {
    const currentMonthData = getCurrentMonthEntries();
    const previousMonthData = getPreviousMonthEntries();
    
    let totalAssets = 0;
    let totalDebts = 0;
    
    currentMonthData.forEach(entry => {
      const category = ASSET_CATEGORIES[entry.asset];
      if (!category) return;
      
      // Parse amount, treating null/undefined/empty as 0
      const amount = parseFloat(entry.amount) || 0;
      
      if (category.isDebt) {
        totalDebts += Math.abs(amount);
      } else {
        totalAssets += amount;
      }
    });
    
    const totalNetWorth = totalAssets - totalDebts;
    
    let previousNetWorth = 0;
    previousMonthData.forEach(entry => {
      const category = ASSET_CATEGORIES[entry.asset];
      if (!category) return;
      
      // Parse amount, treating null/undefined/empty as 0
      const amount = parseFloat(entry.amount) || 0;
      
      if (category.isDebt) {
        previousNetWorth -= Math.abs(amount);
      } else {
        previousNetWorth += amount;
      }
    });
    
    const change = totalNetWorth - previousNetWorth;
    
    _netWorthData.summary = {
      totalNetWorth: totalNetWorth,
      totalAssets: totalAssets,
      totalDebts: totalDebts,
      previousNetWorth: previousNetWorth,
      change: change,
      currentMonth: getMonthName(_currentMonth),
      currentYear: _currentYear,
      previousMonth: getPreviousMonthName(),
      previousYear: getPreviousYear()
    };
    
    updateBannerNetWorth(totalNetWorth);
  }
  
  function updateBannerNetWorth(totalNetWorth) {
    const summaryContainer = document.getElementById('netWorthBannerSummary');
    const valueElement = document.getElementById('netWorthBannerValue');
    
    if (!summaryContainer || !valueElement) {
      return;
    }
    
    if (typeof totalNetWorth === 'number' && !isNaN(totalNetWorth)) {
      valueElement.textContent = formatCurrency(totalNetWorth);
      const summaryElement = document.querySelector('.nw-chart-header');
      if (!summaryElement) {
        summaryContainer.classList.remove('hidden');
      }
    } else {
      summaryContainer.classList.add('hidden');
      valueElement.textContent = '';
    }
  }

  // Update summary display without full re-render
  function updateSummaryDisplay() {
    // Update category totals and changes in the DOM
    Object.keys(ASSET_CATEGORIES).forEach(categoryKey => {
      const total = calculateCategoryTotal(categoryKey);
      const change = calculateCategoryChange(categoryKey);
      const formattedTotal = formatCurrency(total);

      // Find the table for this category, then go up to section to find badge
      const table = document.querySelector(`table.nw-table[data-category="${categoryKey}"]`);
      if (table) {
        const section = table.closest('.nw-section');
        if (section) {
          // Update total
          const badgeTotal = section.querySelector('.nw-badge-total');
          if (badgeTotal) {
            badgeTotal.textContent = formattedTotal;
          }

          // Update change indicator
          const badgeChange = section.querySelector('.nw-badge-change');
          if (badgeChange && change !== 0) {
            const arrow = change > 0 ? '▲' : '▼';
            badgeChange.textContent = `${formatCurrency(Math.abs(change))} ${arrow}`;
            badgeChange.classList.remove('nw-change-positive', 'nw-change-negative');
            // For debts, increasing is bad (red), decreasing is good (green)
            // For assets, increasing is good (green), decreasing is bad (red)
            const category = ASSET_CATEGORIES[categoryKey];
            const isDebt = category && category.isDebt;
            const isPositiveChange = isDebt ? change < 0 : change > 0;
            badgeChange.classList.add(isPositiveChange ? 'nw-change-positive' : 'nw-change-negative');
          } else if (badgeChange && change === 0) {
            badgeChange.textContent = '';
          }
        }
      }
    });

    // Update the main net worth banner value
    if (_netWorthData.summary) {
      const totalNetWorth = _netWorthData.summary.totalNetWorth;
      const valueElement = document.getElementById('netWorthBannerValue');
      if (valueElement) {
        valueElement.textContent = formatCurrency(totalNetWorth);
      }

      // Update the chart header summary (Net Worth, Debts, Change)
      const chartSummary = document.querySelector('.nw-chart-summary');
      if (chartSummary) {
        // Update Net Worth in chart header
        const totalElement = chartSummary.querySelector('.nw-summary-total');
        if (totalElement) {
          const label = totalElement.querySelector('[data-translate="net_worth"]');
          const labelText = label ? label.outerHTML : '<span data-translate="net_worth">Net Worth</span>';
          totalElement.innerHTML = `${labelText}: ${formatCurrency(totalNetWorth)}`;
        }

        // Update Debts in chart header - find element with debts translate attribute
        const debtsLabel = chartSummary.querySelector('[data-translate="debts"]');
        if (debtsLabel) {
          const debtsElement = debtsLabel.closest('.nw-summary-item');
          if (debtsElement) {
            debtsElement.innerHTML = `<span data-translate="debts">Debts</span>: ${formatCurrency(_netWorthData.summary.totalDebts)}`;
          }
        }

        // Update Change indicator - find the element inside summary-line that's not the total
        const change = _netWorthData.summary.change;
        const summaryLine = chartSummary.querySelector('.nw-summary-line');
        if (summaryLine) {
          let changeElement = summaryLine.querySelector('.nw-summary-item:not(.nw-summary-total)');
          if (changeElement) {
            if (change !== 0) {
              const arrow = change > 0 ? '▲' : '▼';
              const changeClass = change > 0 ? 'nw-change-positive' : 'nw-change-negative';
              changeElement.className = `nw-summary-item ${changeClass}`;
              changeElement.textContent = `${formatCurrency(Math.abs(change))} ${arrow}`;
            } else {
              changeElement.textContent = '';
              changeElement.className = 'nw-summary-item';
            }
          }
        }
      }
    }
  }

  function calculateCategoryTotal(categoryKey) {
    const currentMonthData = getCurrentMonthEntries();
    const categoryEntries = currentMonthData.filter(entry => entry.asset === categoryKey);
    
    let total = 0;
    categoryEntries.forEach(entry => {
      const amount = parseFloat(entry.amount) || 0;
      total += amount;
    });
    
    return total;
  }
  
  function calculateCategoryChange(categoryKey) {
    const currentTotal = calculateCategoryTotal(categoryKey);
    
    // Calculate previous month total
    const previousMonthData = getPreviousMonthEntries();
    const previousCategoryEntries = previousMonthData.filter(entry => entry.asset === categoryKey);
    
    let previousTotal = 0;
    previousCategoryEntries.forEach(entry => {
      const amount = parseFloat(entry.amount) || 0;
      previousTotal += amount;
    });
    
    return currentTotal - previousTotal;
  }
  
  function getPreviousMonthEntries() {
    const prevMonth = _currentMonth === 0 ? 11 : _currentMonth - 1;
    const prevYear = _currentMonth === 0 ? _currentYear - 1 : _currentYear;
    
    // FIX BUG 2: Use proper date comparison
    return getEntriesForMonth(prevMonth, prevYear);
  }
  
  function getCurrentMonthEntries() {
    // FIX BUG 2: Use proper date comparison
    return getEntriesForMonth(_currentMonth, _currentYear);
  }
  
  // FIX BUG 2: New robust function for filtering entries by month/year
  function getEntriesForMonth(month, year) {
    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                       'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    
    return _netWorthData.entries.filter(entry => {
      if (!entry.date) return false;
      
      // Handle MMM YYYY format (e.g., "Nov 2024")
      const parts = entry.date.split(' ');
      if (parts.length === 2) {
        const monthStr = parts[0];
        const yearStr = parts[1];
        
        const monthIndex = monthNames.indexOf(monthStr);
        if (monthIndex !== -1) {
          const entryYear = parseInt(yearStr, 10);
          const entryMonth = monthIndex;
          
          const matches = entryMonth === month && entryYear === year;
          
          if (matches) {
            if (entry.amount === null || entry.amount === undefined || entry.amount === '') {
              entry.amount = 0;
            }
          }
          
          return matches;
        }
      }
      
      return false;
    });
  }
  
    function formatDateKey(month, year) {
    // Array of translation keys for abbreviated months
    const monthKeys = [
      "jan", "feb", "mar", "apr", "may", "jun", 
      "jul", "aug", "sep", "oct", "nov", "dec"
    ];
    
    // Get the key for current month
    const monthKey = monthKeys[month];
    
    // Use translation if available, fallback to default abbreviation
    let translatedMonth;
    if (window.SimBudget && SimBudget.translations && SimBudget.translations[monthKey]) {
      translatedMonth = SimBudget.translations[monthKey];
    } else {
      // Fallback to default abbreviations
      const defaultMonths = [
        'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
        'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
      ];
      translatedMonth = defaultMonths[month];
    }
    
    return `${translatedMonth} ${year}`;
  }
  
    function getMonthName(monthNumber) {
    // Array of translation keys for months
    const monthKeys = [
      "january", "february", "march", "april", "may", "june", 
      "july", "august", "september", "october", "november", "december"
    ];
    
    // Get the key for current month
    const monthKey = monthKeys[monthNumber];
    
    // Use translation if available, fallback to default month name
    let translatedMonth;
    if (window.SimBudget && SimBudget.translations && SimBudget.translations[monthKey]) {
      translatedMonth = SimBudget.translations[monthKey];
    } else {
      // Fallback to locale string if translations not available
      translatedMonth = new Date(new Date().getFullYear(), monthNumber, 1)
        .toLocaleString('default', { month: 'long' });
    }
    
    return translatedMonth;
  }
  
  function getPreviousMonthName() {
    const prevMonth = _currentMonth === 0 ? 11 : _currentMonth - 1;
    return getMonthName(prevMonth);
  }
  
  function getPreviousYear() {
    return _currentMonth === 0 ? _currentYear - 1 : _currentYear;
  }
  
  function navigateMonth(direction) {
    let newMonth = _currentMonth + direction;
    let newYear = _currentYear;
    
    if (newMonth > 11) {
      newMonth = 0;
      newYear++;
    } else if (newMonth < 0) {
      newMonth = 11;
      newYear--;
    }
    
    const realNow = new Date();
    const realCurrentMonth = realNow.getMonth();
    const realCurrentYear = realNow.getFullYear();
    
    const maxAllowedMonth = realCurrentMonth === 11 ? 0 : realCurrentMonth + 1;
    const maxAllowedYear = realCurrentMonth === 11 ? realCurrentYear + 1 : realCurrentYear;
    
    if (newYear > maxAllowedYear || (newYear === maxAllowedYear && newMonth > maxAllowedMonth)) {
      return;
    }
    
    _currentMonth = newMonth;
    _currentYear = newYear;
    _autoRolloverCompleted = false;
    
    const currentMonthEntries = getCurrentMonthEntries();
    
    if (currentMonthEntries.length === 0 && isFutureMonth()) {
      showFutureMonthScreen();
    } else {
      calculateSummary();
      renderNetWorthView();
    }
    
    updateMonthYearDisplay();
  }
  
  function isFutureMonth() {
    const realNow = new Date();
    const currentView = new Date(_currentYear, _currentMonth, 1);
    const realCurrent = new Date(realNow.getFullYear(), realNow.getMonth(), 1);
    
    return currentView > realCurrent;
  }
  
  function showFutureMonthScreen() {
    const container = getElement('netWorthContent');
    if (!container) return;
    
    updateBannerNetWorth(null);
    setupSummaryObserver();
    
    const monthName = getMonthName(_currentMonth);
    const prevMonthName = getPreviousMonthName();
    const prevYear = getPreviousYear();
    
    container.innerHTML = `
      <div class="nw-future-message">
        <div class="nw-future-icon">
          <i class="material-icons">event_busy</i>
        </div>
        <h3>${Utils.translateCategory('no_data_exists_for_month').replace('{monthName}', monthName).replace('{year}', _currentYear)}</h3>
        <p>${Utils.translateCategory('can_only_record_current_next_month')}</p>
        <button id="copyFromPrevBtn" class="nw-btn nw-btn-primary">
          <i class="material-icons">content_copy</i> ${Utils.translateCategory('copy_data_from_prev_month').replace('{prevMonthName}', prevMonthName).replace('{prevYear}', prevYear)}
        </button>
      </div>
    `;
    
    const copyBtn = getElement('copyFromPrevBtn');
    if (copyBtn) {
      copyBtn.addEventListener('click', function() {
        copyFromPreviousMonth();
      });
    }
  }
  
  function copyFromPreviousMonth() {
    try {
      // Validate current state
      if (!isFutureMonth() && getCurrentMonthEntries().length > 0) {
        showMessage(getTranslation('current_month_has_data'), 'warning');
        return;
      }
      
      // Get previous month data
      const previousMonthEntries = getPreviousMonthEntries();
      const prevMonthName = getPreviousMonthName();
      const prevYear = getPreviousYear();
      
      if (previousMonthEntries.length === 0) {
        showMessage(`No data found in ${prevMonthName} ${prevYear} to copy`, 'error');
        return;
      }
      
      // Show loading state
      showMessage(getTranslation('copying_data_from_previous_month'), 'info');
      
      // Check for existing entries to avoid duplicates
      const existingEntries = getCurrentMonthEntries();
      const existingKeys = new Set();
      
      existingEntries.forEach(entry => {
        const key = `${entry.asset}|${entry.name}|${entry.type}`;
        existingKeys.add(key);
      });
      
      // Prepare new entries
      const newEntries = [];
      const skippedEntries = [];
      
      previousMonthEntries.forEach(entry => {
        const key = `${entry.asset}|${entry.name}|${entry.type}`;
        
        if (!existingKeys.has(key)) {
          // Validate required fields
          if (!entry.asset || !entry.name) {
            console.warn('Skipping invalid entry:', entry);
            return;
          }
          
          // Create new entry with current month date
          const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                             'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
          const currentMonthDate = `${monthNames[_currentMonth]} ${_currentYear}`;
          const newEntry = {
            ...entry,
            date: currentMonthDate,
            id: `copy-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            notes: entry.notes || '',
            // Ensure amount is valid number, default to 0 if invalid
            amount: entry.amount !== undefined && entry.amount !== null && entry.amount !== '' 
              ? parseFloat(entry.amount) || 0 
              : 0
          };
          
          newEntries.push(newEntry);
        } else {
          skippedEntries.push(entry.name);
        }
      });
      
      // Handle results
      if (newEntries.length === 0) {
        if (skippedEntries.length > 0) {
          showMessage(`All ${skippedEntries.length} entries from ${prevMonthName} already exist in current month`, 'info');
        } else {
          showMessage(`No valid entries found to copy from ${prevMonthName}`, 'warning');
        }
        return;
      }
      
      // Add entries to data
      _netWorthData.entries = _netWorthData.entries.concat(newEntries);
      
      // Save to server
      saveNetWorthEntries(newEntries);
      
      // Update UI
      assignColorsToAssetTypes();
      calculateSummary();
      renderNetWorthView();
      bindEventHandlers();
      
      // Show success message with details
      let message = Utils.translateCategory('automatically_copied_assets').replace('{count}', newEntries.length).replace('{prevMonthName}', `${prevMonthName} ${prevYear}`);
      if (skippedEntries.length > 0) {
        message += ` (${skippedEntries.length} already existed)`;
      }
      showMessage(message, 'success');
      
      
    } catch (error) {
      console.error('NetWorth: Error copying from previous month:', error);
      showMessage(getTranslation('error_copying_data_from_previous_month'), 'error');
    }
  }
  
  function updateMonthYearDisplay() {
    const displayElement = document.getElementById('monthYearDisplayNetWorth');
    if (displayElement) {
      displayElement.textContent = `${getMonthName(_currentMonth)} ${_currentYear}`;
    }
  }
  
  function initializeMonthNavigation() {
    const prevMonthBtn = document.getElementById('prevMonthNetWorth');
    const nextMonthBtn = document.getElementById('nextMonthNetWorth');
    const refreshBtn = document.getElementById('refreshNetWorth');
    
    if (prevMonthBtn) {
      const newPrevBtn = prevMonthBtn.cloneNode(true);
      prevMonthBtn.parentNode.replaceChild(newPrevBtn, prevMonthBtn);
      newPrevBtn.addEventListener('click', function() {
        navigateMonth(-1);
      });
    }
    
    if (nextMonthBtn) {
      const newNextBtn = nextMonthBtn.cloneNode(true);
      nextMonthBtn.parentNode.replaceChild(newNextBtn, nextMonthBtn);
      newNextBtn.addEventListener('click', function() {
        navigateMonth(1);
      });
    }
    
    if (refreshBtn) {
      const newRefreshBtn = refreshBtn.cloneNode(true);
      refreshBtn.parentNode.replaceChild(newRefreshBtn, refreshBtn);
      newRefreshBtn.addEventListener('click', function() {
        refresh();
      });
    }
    
    // Add click-to-edit functionality for month/year display
    const monthYearDisplay = document.getElementById('monthYearDisplayNetWorth');
    if (monthYearDisplay) {
      const newDisplay = monthYearDisplay.cloneNode(true);
      monthYearDisplay.parentNode.replaceChild(newDisplay, monthYearDisplay);
      newDisplay.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        showMonthYearEditor('monthYearDisplayNetWorth');
      });
    }
    
    updateMonthYearDisplay();
  }
  
  // Chart functions - FIXED BUG 2: Proper month filtering

  // Get available years from data for performance chart
  function getAvailableYears() {
    if (!_netWorthData || !_netWorthData.entries || _netWorthData.entries.length === 0) {
      return [new Date().getFullYear()];
    }

    const years = new Set();
    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                       'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

    _netWorthData.entries.forEach(entry => {
      if (!entry.date) return;

      const parts = entry.date.split(' ');
      if (parts.length === 2) {
        const yearStr = parts[1];
        const year = parseInt(yearStr, 10);
        if (!isNaN(year)) {
          years.add(year);
        }
      }
    });

    // Convert to sorted array (oldest to newest)
    const sortedYears = Array.from(years).sort((a, b) => a - b);

    // If no years found, return current year
    if (sortedYears.length === 0) {
      return [new Date().getFullYear()];
    }

    // For mobile, limit to last 5 years
    const isMobile = window.innerWidth < 768;
    if (isMobile && sortedYears.length > 5) {
      return sortedYears.slice(-5); // Get last 5 years only
    }

    return sortedYears;
  }

  // Calculate monthly performance for a specific year
  function calculateMonthlyPerformance(year) {
    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                       'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    const monthlyData = [];
    const monthlyPercentages = [];

    // Get current date to determine which months to show
    const now = new Date();
    const currentYear = now.getFullYear();
    const currentMonth = now.getMonth(); // 0-11

    // Determine the last month to show
    let lastMonthToShow = 11; // December by default
    if (year === currentYear) {
      lastMonthToShow = currentMonth; // Only show up to current month for current year
    } else if (year > currentYear) {
      // Future year - show no data
      return {
        monthlyPercentages: [],
        yearlyPerformance: 0
      };
    }

    // Calculate net worth for each month of the year (up to lastMonthToShow)
    for (let month = 0; month <= lastMonthToShow; month++) {
      const monthEntries = getEntriesForMonth(month, year);
      let totalNetWorth = 0;
      let hasEntries = monthEntries.length > 0;

      monthEntries.forEach(entry => {
        const category = ASSET_CATEGORIES[entry.asset];
        if (!category) return;

        const amount = parseFloat(entry.amount) || 0;
        if (Math.abs(amount) < 1) return;

        if (category.isDebt) {
          totalNetWorth -= Math.abs(amount);
        } else {
          totalNetWorth += amount;
        }
      });

      monthlyData.push({
        month: monthNames[month],
        netWorth: totalNetWorth,
        hasEntries: hasEntries
      });
    }

    // Calculate percentage changes
    for (let i = 0; i < monthlyData.length; i++) {
      const currentNetWorth = monthlyData[i].netWorth;
      const currentHasEntries = monthlyData[i].hasEntries;
      let previousNetWorth = 0;
      let previousHasEntries = false;

      if (i === 0) {
        // For January, compare to December of previous year
        const prevYearDecEntries = getEntriesForMonth(11, year - 1);
        previousHasEntries = prevYearDecEntries.length > 0;

        prevYearDecEntries.forEach(entry => {
          const category = ASSET_CATEGORIES[entry.asset];
          if (!category) return;

          const amount = parseFloat(entry.amount) || 0;
          if (Math.abs(amount) < 1) return;

          if (category.isDebt) {
            previousNetWorth -= Math.abs(amount);
          } else {
            previousNetWorth += amount;
          }
        });
      } else {
        previousNetWorth = monthlyData[i - 1].netWorth;
        previousHasEntries = monthlyData[i - 1].hasEntries;
      }

      // Only calculate and show percentage if both current and previous months have data
      let percentChange = 0;
      let shouldShow = false;

      if (currentHasEntries && previousHasEntries) {
        shouldShow = true;
        if (previousNetWorth !== 0) {
          percentChange = ((currentNetWorth - previousNetWorth) / Math.abs(previousNetWorth)) * 100;
        } else if (currentNetWorth !== 0) {
          // If previous is 0 but current is not, show 100% or -100%
          percentChange = currentNetWorth > 0 ? 100 : -100;
        }
      }

      monthlyPercentages.push({
        month: monthlyData[i].month,
        percentage: percentChange,
        netWorth: currentNetWorth,
        hasData: shouldShow
      });
    }

    // Calculate yearly performance by summing all monthly percentages
    let yearlyPerformance = 0;
    monthlyPercentages.forEach(month => {
      if (month.hasData) {
        yearlyPerformance += month.percentage;
      }
    });

    return {
      monthlyPercentages,
      yearlyPerformance
    };
  }

    function getChartData(timespan) {
    const months = getMonthsForTimespan(timespan);
    const labels = [];
    const netWorthData = [];
    const assetTypeData = {};
    
    months.forEach(monthData => {
      const monthKey = `${monthData.shortName} ${monthData.year}`;
      labels.push(monthKey);
      
      // FIX BUG 2: Use the robust month filtering function
      const monthEntries = getEntriesForMonth(monthData.month, monthData.year);
      
      let totalAssets = 0;
      let totalDebts = 0;
      const typeAmounts = {};
      
      monthEntries.forEach(entry => {
        const category = ASSET_CATEGORIES[entry.asset];
        if (!category) return;
        
        // Parse amount, treating null/undefined/empty as 0
        const amount = parseFloat(entry.amount) || 0;
        
        // NEW: Skip amounts less than 1 for chart rendering
        if (Math.abs(amount) < 1) return;
        
        const type = entry.type || 'Other';
        
        if (!typeAmounts[type]) {
          typeAmounts[type] = 0;
        }
        
        // Include all values in calculations, even if 0
        if (category.isDebt) {
          typeAmounts[type] -= Math.abs(amount);
          totalDebts += Math.abs(amount);
        } else {
          typeAmounts[type] += amount;
          totalAssets += amount;
        }
      });
      
      netWorthData.push(totalAssets - totalDebts);
      
      // Store amounts for each asset type
      Object.keys(typeAmounts).forEach(type => {
        if (!assetTypeData[type]) {
          assetTypeData[type] = new Array(labels.length).fill(0);
        }
        assetTypeData[type][labels.length - 1] = typeAmounts[type];
      });
    });
    
    // Ensure all arrays are the same length
    Object.keys(assetTypeData).forEach(type => {
      while (assetTypeData[type].length < labels.length) {
        assetTypeData[type].push(0);
      }
    });
    
    // Add projections if viewing 'thisyear' timespan
    const projections = calculateProjections(timespan);
    const allLabels = [...labels, ...projections.projectedLabels];
    const allNetWorthData = [...netWorthData, ...projections.projectedValues];
    
    // Mark where projections start for visual styling
    const projectionStartIndex = labels.length;
    
    return {
      labels: allLabels,
      netWorthData: allNetWorthData,
      assetTypeData,
      projectionStartIndex: projectionStartIndex,
      hasProjections: projections.projectedLabels.length > 0
    };
  }
  
  function getMonthsForTimespan(timespan) {
    const months = [];
    const now = new Date();
    let startDate;
    
    switch (timespan) {
        case 'thisyear':
      startDate = new Date(now.getFullYear(), 0, 1); // January 1st of current year
      break;
      case '12m':
        startDate = new Date(now.getFullYear(), now.getMonth() - 11, 1);
        break;
      case '2yr':
        startDate = new Date(now.getFullYear() - 2, now.getMonth(), 1);
        break;
      case '3yr':
        startDate = new Date(now.getFullYear() - 3, now.getMonth(), 1);
        break;
      case '5yr':
        startDate = new Date(now.getFullYear() - 5, now.getMonth(), 1);
        break;
      case 'all':
        // Find earliest entry
        if (_netWorthData.entries.length > 0) {
          const earliestDate = new Date(Math.min(..._netWorthData.entries.map(e => new Date(e.date || now))));
          startDate = new Date(earliestDate.getFullYear(), earliestDate.getMonth(), 1);
        } else {
          startDate = new Date(now.getFullYear(), now.getMonth() - 11, 1);
        }
        break;
      default:
        startDate = new Date(now.getFullYear(), now.getMonth() - 11, 1);
    }
    
    const currentDate = new Date(startDate);
    while (currentDate <= now) {
      const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      months.push({
        month: currentDate.getMonth(),
        year: currentDate.getFullYear(),
        shortName: monthNames[currentDate.getMonth()]
      });
      currentDate.setMonth(currentDate.getMonth() + 1);
    }
    
    return months;
  }
  
  function calculateProjections(timespan) {
    // Only calculate projections for 'thisyear' timespan
    if (timespan !== 'thisyear') {
      return { projectedLabels: [], projectedValues: [] };
    }
    
    const now = new Date();
    const currentYear = now.getFullYear();
    const currentMonth = now.getMonth();
    
    // Get historical data for trend calculation (last 3-6 months)
    const historicalMonths = Math.min(6, currentMonth + 1); // Don't go beyond current year
    const trendData = [];
    
    for (let i = Math.max(0, currentMonth - historicalMonths + 1); i <= currentMonth; i++) {
      const monthEntries = getEntriesForMonth(i, currentYear);
      let totalNetWorth = 0;
      
      monthEntries.forEach(entry => {
        const category = ASSET_CATEGORIES[entry.asset];
        if (!category) return;
        
        const amount = parseFloat(entry.amount) || 0;
        if (Math.abs(amount) < 1) return;
        
        if (category.isDebt) {
          totalNetWorth -= Math.abs(amount);
        } else {
          totalNetWorth += amount;
        }
      });
      
      trendData.push(totalNetWorth);
    }
    
    // Calculate average monthly change
    let totalChange = 0;
    let changeCount = 0;
    
    for (let i = 1; i < trendData.length; i++) {
      totalChange += trendData[i] - trendData[i - 1];
      changeCount++;
    }
    
    const avgMonthlyChange = changeCount > 0 ? totalChange / changeCount : 0;
    
    // Generate projections for remaining months of the year
    const projectedLabels = [];
    const projectedValues = [];
    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    
    if (trendData.length > 0) {
      // Get the current month's actual net worth value as starting point
      const currentMonthEntries = getEntriesForMonth(currentMonth, currentYear);
      let currentMonthValue = 0;
      
      currentMonthEntries.forEach(entry => {
        const category = ASSET_CATEGORIES[entry.asset];
        if (!category) return;
        
        const amount = parseFloat(entry.amount) || 0;
        if (Math.abs(amount) < 1) return;
        
        if (category.isDebt) {
          currentMonthValue -= Math.abs(amount);
        } else {
          currentMonthValue += amount;
        }
      });
      
      // Start projections from NEXT month, using current month's value as base
      let lastValue = currentMonthValue;
      
      for (let month = currentMonth + 1; month <= 11; month++) {
        lastValue += avgMonthlyChange;
        projectedLabels.push(`${monthNames[month]} ${currentYear}`);
        projectedValues.push(lastValue);
      }
    }
    
    return { projectedLabels, projectedValues };
  }
  
  // Track chart collapsed state - load from localStorage or default to collapsed
  let _chartCollapsed = localStorage.getItem('nwChartCollapsed') !== 'false';

  function renderNetWorthChart(summary) {
  const currentYear = new Date().getFullYear();

  // Get available years for performance mode
  const availableYears = getAvailableYears();

  // Format change display
  const change = summary.change || 0;
  const changeArrow = change >= 0 ? '▲' : '▼';
  const changeClass = change >= 0 ? 'nw-change-positive' : 'nw-change-negative';
  const changeDisplay = `${formatCurrency(Math.abs(change))} ${changeArrow}`;

  return `
    <div class="nw-chart-container ${_chartCollapsed ? 'chart-collapsed' : ''}">
      <div class="nw-chart-header">
        <div class="nw-chart-summary">
          <span class="nw-summary-line">
            <span class="nw-summary-item nw-summary-total">
              <span data-translate="net_worth">Net Worth</span>: ${formatCurrency(summary.totalNetWorth)}
            </span>
            <span class="nw-summary-item ${changeClass}">${changeDisplay}</span>
          </span>
          <span class="nw-summary-separator">|</span>
          <span class="nw-summary-item">
            <span data-translate="debts">Debts</span>: ${formatCurrency(summary.totalDebts)}
          </span>
        </div>
        <button class="nw-chart-toggle" id="nwChartToggleBtn" title="Toggle chart visibility">
          <span class="nw-chart-toggle-icon">${_chartCollapsed ? '▲' : '▼'}</span>
        </button>
      </div>
      <div class="nw-chart-content" id="nwChartContent" style="display: ${_chartCollapsed ? 'none' : 'block'};">
        <div class="nw-chart-wrapper">
          <canvas id="netWorthChart" width="800" height="400"></canvas>
        </div>
        <div class="nw-chart-controls-bar">
          <div class="nw-chart-controls">
            <div class="nw-mode-buttons">
              <button class="nw-mode-btn ${_chartMode === 'performance' ? 'active' : ''}" id="performanceBtn" title="Performance">
                <i class="material-icons">bar_chart</i>
              </button>
              <button class="nw-mode-btn ${_chartMode === 'timeline' ? 'active' : ''}" id="timelineBtn" title="Timeline">
                <i class="material-icons">show_chart</i>
              </button>
              <button class="nw-mode-btn ${_chartMode === 'allocation' ? 'active' : ''}" id="allocationBtn" title="Allocation">
                <i class="material-icons">pie_chart</i>
              </button>
            </div>

            <div class="nw-timespan-controls ${_chartMode === 'performance' ? '' : 'hidden'}" id="performanceYearControls">
              ${availableYears.length > 3 ? `<button class="nw-timespan-btn nw-more-years-btn" id="moreYearsBtn" title="Show earlier years">...</button>` : ''}
              ${availableYears.length > 3 ?
                availableYears.slice(0, -3).map(year =>
                  `<button class="nw-timespan-btn nw-older-year ${_selectedYear === year ? 'active' : ''}" data-year="${year}" style="display: none;">${year}</button>`
                ).join('') : ''}
              ${availableYears.slice(-3).map(year =>
                `<button class="nw-timespan-btn ${_selectedYear === year ? 'active' : ''}" data-year="${year}">${year}</button>`
              ).join('')}
            </div>

            <div class="nw-timespan-controls ${_chartMode === 'timeline' ? '' : 'hidden'}" id="timelineTimespanControls">
              <button class="nw-timespan-btn ${_chartTimespan === 'thisyear' ? 'active' : ''}" data-timespan="thisyear">${currentYear}</button>
              <button class="nw-timespan-btn ${_chartTimespan === '12m' ? 'active' : ''}" data-timespan="12m">12m</button>
              <button class="nw-timespan-btn ${_chartTimespan === '2yr' ? 'active' : ''}" data-timespan="2yr">2yr</button>
              <button class="nw-timespan-btn ${_chartTimespan === '3yr' ? 'active' : ''}" data-timespan="3yr">3yr</button>
              <button class="nw-timespan-btn ${_chartTimespan === '5yr' ? 'active' : ''}" data-timespan="5yr">5yr</button>
              <button class="nw-timespan-btn nw-all-btn ${_chartTimespan === 'all' ? 'active' : ''}" data-timespan="all" data-translate="all_button">All</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  `;
}

  /**
   * Toggle chart visibility
   */
  function toggleNwChart() {
    const chartContent = document.getElementById('nwChartContent');
    const chartContainer = document.querySelector('.nw-chart-container');
    const toggleIcon = document.querySelector('.nw-chart-toggle-icon');

    if (!chartContent || !chartContainer) return;

    _chartCollapsed = !_chartCollapsed;
    localStorage.setItem('nwChartCollapsed', _chartCollapsed);

    if (_chartCollapsed) {
      chartContent.style.display = 'none';
      chartContainer.classList.add('chart-collapsed');
      if (toggleIcon) toggleIcon.textContent = '▲';
    } else {
      chartContent.style.display = 'block';
      chartContainer.classList.remove('chart-collapsed');
      if (toggleIcon) toggleIcon.textContent = '▼';

      // Initialize chart if it doesn't exist or needs refresh
      setTimeout(() => {
        initializeChart();
      }, 50);
    }
  }
  
  // FIX BUG 3: Enhanced Chart.js plugin for proper value positioning
  // Replace your existing valuesPlugin with this boundary-aware version:
 const valuesPlugin = {
  id: 'valuesAboveBars',
  afterDatasetsDraw: function(chart) {
    const ctx = chart.ctx;
    const chartData = getChartData(_chartTimespan);
    
    if (!chartData || !chartData.netWorthData || chartData.netWorthData.length === 0) {
      return;
    }
    
    // CRITICAL: Get the actual drawing boundaries
    const chartArea = chart.chartArea;
    const topBoundary = chartArea.top + 5; // Small margin from top
    
    // Format values
    const values = chartData.netWorthData.map(value => {
      if (Math.abs(value) >= 1000000) {
        return `${Math.round(value / 1000000)}M`;
      } else if (Math.abs(value) >= 1000) {
        return `${Math.round(value / 1000)}k`;
      } else {
        return `${Math.round(value)}`;
      }
    });
    
    const changes = chartData.netWorthData.map((value, index) => {
      if (index === 0) return '';
      const change = value - chartData.netWorthData[index - 1];
      const sign = change >= 0 ? '+' : '';
      if (Math.abs(change) >= 1000000) {
        return `${sign}${Math.round(change / 1000000)}M`;
      } else if (Math.abs(change) >= 1000) {
        return `${sign}${Math.round(change / 1000)}k`;
      } else {
        return `${sign}${Math.round(change)}`;
      }
    });
    
    // Get net worth line dataset
    const netWorthDatasetIndex = chart.data.datasets.length - 1;
    const netWorthMeta = chart.getDatasetMeta(netWorthDatasetIndex);
    
    if (!netWorthMeta || !netWorthMeta.data) return;
    
    // Draw values with strict boundary checking
    chart.data.labels.forEach((label, index) => {
      const point = netWorthMeta.data[index];
      if (!point) return;
      
      const x = point.x;
      let highestY = point.y;
      
      // Find the highest stacked bar
      for (let i = 0; i < chart.data.datasets.length - 1; i++) {
        const barMeta = chart.getDatasetMeta(i);
        if (barMeta && barMeta.data && barMeta.data[index]) {
          const bar = barMeta.data[index];
          highestY = Math.min(highestY, bar.y);
        }
      }
      
      // Calculate label positions
      const fontSize = window.innerWidth < 768 ? 10 : 12;
      const valueY = highestY - (window.innerWidth < 768 ? 20 : 25);
      const changeY = highestY - (window.innerWidth < 768 ? 8 : 10);
      
      // CRITICAL: Only draw if within boundaries
      if (valueY >= topBoundary) {
        ctx.save();
        ctx.fillStyle = '#2c3e50';
        ctx.font = `bold ${fontSize}px Lato, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.fillText(values[index], x, valueY);
        
        // Draw change only if there's enough space
        if (changes[index] && changeY >= topBoundary && changeY > valueY + fontSize) {
          const changeColor = changes[index].startsWith('+') ? '#4caf50' : '#f44336';
          ctx.fillStyle = changeColor;
          ctx.font = `600 ${fontSize - 2}px Lato, sans-serif`;
          ctx.fillText(changes[index], x, changeY);
        }
        
        ctx.restore();
      }
    });
  }
 };
  
  function updateChartModeUI() {
    // Update button active states
    const performanceBtn = document.getElementById('performanceBtn');
    const timelineBtn = document.getElementById('timelineBtn');
    const allocationBtn = document.getElementById('allocationBtn');

    if (performanceBtn) performanceBtn.classList.toggle('active', _chartMode === 'performance');
    if (timelineBtn) timelineBtn.classList.toggle('active', _chartMode === 'timeline');
    if (allocationBtn) allocationBtn.classList.toggle('active', _chartMode === 'allocation');

    // Update timespan controls visibility
    const performanceYearControls = document.getElementById('performanceYearControls');
    const timelineTimespanControls = document.getElementById('timelineTimespanControls');

    if (performanceYearControls) {
      performanceYearControls.classList.toggle('hidden', _chartMode !== 'performance');
    }

    if (timelineTimespanControls) {
      timelineTimespanControls.classList.toggle('hidden', _chartMode !== 'timeline');
    }

    const chartContainer = document.querySelector('.nw-chart-container');
    if (chartContainer) {
      chartContainer.classList.toggle('allocation-mode', _chartMode === 'allocation');
    }
  }

  function initializeChart() {
    if (_chartMode === 'performance') {
      initializePerformanceChart();
    } else if (_chartMode === 'timeline') {
      initializeTimelineChart();
    } else {
      initializeAllocationChart();
    }
  }

  function initializeTimelineChart() {
  const canvas = document.getElementById('netWorthChart');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  const chartData = getChartData(_chartTimespan);
  
  // Destroy existing chart
  if (_chart) {
    _chart.destroy();
  }
  
  const datasets = [];
  
  // Sort asset types for consistent stacking order
  const sortedTypes = Object.keys(chartData.assetTypeData).sort();
  
  sortedTypes.forEach(type => {
    const color = ASSET_TYPE_COLORS[type] || '#95a5a6';
    // Only add dataset if it has at least one non-zero value
    const hasNonZeroValue = chartData.assetTypeData[type].some(val => val !== 0);
    
    if (hasNonZeroValue || sortedTypes.length === 1) { // Always show if it's the only type
      datasets.push({
        label: type,
        data: chartData.assetTypeData[type],
        backgroundColor: color,
        borderColor: color,
        borderWidth: 1,
        type: 'bar',
        stack: 'assets',
        order: 2 // Bars drawn first
      });
    }
  });
  
  // Add net worth line - separate datasets for historical and projected
  if (chartData.hasProjections) {
    // Historical data only (no future values)
    const historicalData = new Array(chartData.labels.length).fill(null);
    for (let i = 0; i < chartData.projectionStartIndex; i++) {
      historicalData[i] = chartData.netWorthData[i];
    }
    
    datasets.push({
      label: 'Net Worth',
      data: historicalData,
      borderColor: '#2c3e50',
      backgroundColor: 'transparent',
      type: 'line',
      tension: 0.4,
      pointBackgroundColor: '#2c3e50',
      pointBorderColor: '#fff',
      pointBorderWidth: 2,
      pointRadius: 4,
      pointHoverRadius: 6,
      borderWidth: 3,
      order: 1
    });
    
    // Projected data only (no historical values)
    const projectionData = new Array(chartData.labels.length).fill(null);
    for (let i = chartData.projectionStartIndex; i < chartData.netWorthData.length; i++) {
      projectionData[i] = chartData.netWorthData[i];
    }
    
    datasets.push({
      label: 'Projected Net Worth',
      data: projectionData,
      borderColor: 'rgba(231, 76, 60, 0.7)',
      backgroundColor: 'transparent',
      type: 'line',
      tension: 0.4,
      pointBackgroundColor: 'rgba(231, 76, 60, 0.7)',
      pointBorderColor: '#fff',
      pointBorderWidth: 2,
      pointRadius: 3,
      pointHoverRadius: 5,
      borderWidth: 2,
      borderDash: [8, 4], // Dashed line for projections
      order: 1
    });
  } else {
    // No projections, show regular line
    datasets.push({
      label: 'Net Worth',
      data: chartData.netWorthData,
      borderColor: '#2c3e50',
      backgroundColor: 'transparent',
      type: 'line',
      tension: 0.4,
      pointBackgroundColor: '#2c3e50',
      pointBorderColor: '#fff',
      pointBorderWidth: 2,
      pointRadius: 4,
      pointHoverRadius: 6,
      borderWidth: 3,
      order: 1
    });
  }
  
  // Detect mobile
  const isMobile = window.innerWidth < 768;
  
  // BOUNDARY-AWARE VALUES PLUGIN - BUILT INTO THE CHART
  const boundaryAwareValuesPlugin = {
    id: 'valuesAboveBars',
    afterDatasetsDraw: function(chart) {
      const ctx = chart.ctx;
      
      if (!chartData || !chartData.netWorthData || chartData.netWorthData.length === 0) {
        return;
      }
      
      // GET STRICT BOUNDARIES FROM CHART.JS
      const chartArea = chart.chartArea;
      const topLimit = chartArea.top + 2; // Absolute top boundary with tiny margin
      const bottomLimit = chartArea.bottom - 2; // Absolute bottom boundary
      
      // Format values efficiently
      const values = chartData.netWorthData.map(value => {
        if (Math.abs(value) >= 1000000) {
          return `${Math.round(value / 1000000)}M`;
        } else if (Math.abs(value) >= 1000) {
          return `${Math.round(value / 1000)}k`;
        } else {
          return `${Math.round(value)}`;
        }
      });
      
      const changes = chartData.netWorthData.map((value, index) => {
        if (index === 0) return '';
        const change = value - chartData.netWorthData[index - 1];
        const sign = change >= 0 ? '+' : '';
        if (Math.abs(change) >= 1000000) {
          return `${sign}${Math.round(change / 1000000)}M`;
        } else if (Math.abs(change) >= 1000) {
          return `${sign}${Math.round(change / 1000)}k`;
        } else {
          return `${sign}${Math.round(change)}`;
        }
      });
      
      // Get the net worth line dataset (last dataset)
      const netWorthDatasetIndex = chart.data.datasets.length - 1;
      const netWorthMeta = chart.getDatasetMeta(netWorthDatasetIndex);
      
      if (!netWorthMeta || !netWorthMeta.data) return;
      
      // Calculate font sizes
      const valueFontSize = isMobile ? 9 : 12;
      const changeFontSize = isMobile ? 8 : 10;
      const lineHeight = valueFontSize + 2;
      
      // Draw values with ABSOLUTE boundary enforcement
      // Different display intervals based on device and timeframe
      const shouldShowQuarterly = _chartTimespan === '3yr' || _chartTimespan === '5yr' || _chartTimespan === 'all';
      
      chart.data.labels.forEach((label, index) => {
        // On mobile: different intervals based on timeframe
        if (isMobile) {
          // Current Year and 12m: show every month
          if (_chartTimespan === 'thisyear' || _chartTimespan === '12m') {
            // Show all months - no skipping
          }
          // 2yr: show every 2 months
          else if (_chartTimespan === '2yr' && index % 2 !== 0) return;
          // 3yr, 5yr, All: show every 4 months
          else if ((_chartTimespan === '3yr' || _chartTimespan === '5yr' || _chartTimespan === 'all') && index % 4 !== 0) return;
        } else {
          // On desktop: show quarterly for longer timeframes, monthly for shorter
          if (shouldShowQuarterly && index % 3 !== 0) return;
        }
        const point = netWorthMeta.data[index];
        if (!point) return;
        
        const x = point.x;
        let highestY = point.y; // Start with net worth line position
        
        // Find the actual highest point considering all stacked bars
        for (let i = 0; i < chart.data.datasets.length - 1; i++) { // Exclude the line dataset
          const barMeta = chart.getDatasetMeta(i);
          if (barMeta && barMeta.data && barMeta.data[index]) {
            const bar = barMeta.data[index];
            // For stacked bars, we need the topmost position
            highestY = Math.min(highestY, bar.y); // Lower y value = higher position
          }
        }
        
        // Calculate label positions with spacing
        const valueSpacing = isMobile ? 16 : 22;
        const changeSpacing = isMobile ? 6 : 8;
        
        const valueY = highestY - valueSpacing;
        const changeY = highestY - changeSpacing;
        
        // CRITICAL: Only draw values if they fit within the top boundary
        if (valueY >= topLimit && valueY <= bottomLimit) {
          ctx.save();
          ctx.fillStyle = document.body.classList.contains('dark-mode') ? '#DDA15E' : '#2c3e50';
          ctx.font = `bold ${valueFontSize}px Lato, sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          
          // Ensure we're not drawing outside canvas bounds
          if (x >= chartArea.left && x <= chartArea.right) {
            ctx.fillText(values[index], x, valueY);
          }
          
             // Draw change value only if there's enough space and it fits
          if (changes[index] && changeY >= topLimit && changeY <= bottomLimit && changeY !== valueY) {
              const isPositive = changes[index].startsWith('+');
              const isDarkMode = document.body.classList.contains('dark-mode');
              const changeColor = isDarkMode 
                  ? (isPositive ? '#66bb6a' : '#ef5350') // Lighter green/red in dark mode
                  : (isPositive ? '#4caf50' : '#f44336'); // Normal green/red in light mode
              ctx.fillStyle = changeColor;
              ctx.font = `600 ${changeFontSize}px Lato, sans-serif`;
              ctx.fillText(changes[index], x, changeY);
          }
          
          ctx.restore();
        }
      });
    }
  };
  
  _chart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: chartData.labels,
      datasets: datasets
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      
      // CRITICAL: Reserve space for labels to prevent overflow
      layout: {
        padding: {
          top: isMobile ? 25 : 35,     // Reserve space for value labels
          bottom: isMobile ? 5 : 10,   // Minimal bottom space 
          left: isMobile ? 5 : 10,
          right: isMobile ? 5 : 10
        }
      },
      
      // Force chart to fit within container
      elements: {
        point: {
          radius: isMobile ? 3 : 4,
          hoverRadius: isMobile ? 4 : 6
        }
      },
      
      interaction: {
        mode: 'nearest',
        intersect: true
      },
      
      plugins: {
        legend: {
          display: !isMobile, // Hide legend on mobile to save space
          position: 'left', 
          align: 'center',
          fullSize: false,
          maxHeight: 200,
          labels: {
            usePointStyle: true,
            padding: 10,
            font: {
              size: 11,
              family: 'Lato, sans-serif'
            },
            boxWidth: 15,
            boxHeight: 15
          }
        },
        tooltip: {
          backgroundColor: 'rgba(0,0,0,0.8)',
          titleColor: '#fff',
          bodyColor: '#fff',
          titleFont: {
            size: 13,
            weight: 'bold'
          },
          bodyFont: {
            size: 12
          },
          padding: 10,
          displayColors: true,
          callbacks: {
            label: function(context) {
              const value = context.parsed.y;
              return `${context.dataset.label}: ${formatCurrency(value)}`;
            }
          }
        }
      },
      
      scales: {
        x: {
          stacked: true,
          grid: {
            display: false
          },
          ticks: {
            font: {
              size: isMobile ? 9 : 11,
              family: 'Lato, sans-serif'
            },
            // Rotate labels based on device and timeframe
            maxRotation: function() {
              if (isMobile) {
                // Mobile: 45 degrees for all timeframes
                return 45;
              } else {
                // Desktop: 0 degrees for Current Year and 12m, 90 for others
                return (_chartTimespan === 'thisyear' || _chartTimespan === '12m') ? 0 : 90;
              }
            }(),
            minRotation: function() {
              if (isMobile) {
                // Mobile: 45 degrees for all timeframes
                return 45;
              } else {
                // Desktop: 0 degrees for Current Year and 12m, 90 for others
                return (_chartTimespan === 'thisyear' || _chartTimespan === '12m') ? 0 : 90;
              }
            }(),
            // Show all labels for short timeframes on mobile
            autoSkip: false,
            callback: function(value, index) {
              if (isMobile) {
                // Current Year and 12m: show all months
                if (_chartTimespan === 'thisyear' || _chartTimespan === '12m') {
                  return this.getLabelForValue(value);
                }
                // 2yr: show every 2 months
                else if (_chartTimespan === '2yr') {
                  return index % 2 === 0 ? this.getLabelForValue(value) : '';
                }
                // 3yr, 5yr, All: show every 4 months
                else if (_chartTimespan === '3yr' || _chartTimespan === '5yr' || _chartTimespan === 'all') {
                  return index % 4 === 0 ? this.getLabelForValue(value) : '';
                }
              }
              // Desktop: show all labels
              return this.getLabelForValue(value);
            }
          }
        },
        y: {
          stacked: true,
          beginAtZero: true,
          // Tighter scaling to prevent labels going outside
          suggestedMax: function(context) {
            const maxValue = Math.max(...context.chart.data.datasets.map(d => 
              Math.max(...d.data.filter(v => v !== null && v !== undefined))
            ));
            return maxValue * (isMobile ? 1.08 : 1.12); // Tighter scaling on mobile
          },
          position: isMobile ? 'bottom' : 'left',
          grid: {
            color: 'rgba(0,0,0,0.08)',
            drawBorder: false
          },
          ticks: {
            callback: function(value) {
              if (Math.abs(value) >= 1000000) {
                return `${value / 1000000}M`;
              } else if (Math.abs(value) >= 1000) {
                return `${value / 1000}k`;
              }
              return value;
            },
            font: {
              size: isMobile ? 9 : 11,
              family: 'Lato, sans-serif'
            },
            maxTicksLimit: isMobile ? 5 : 8 // Fewer ticks on mobile
          }
        }
      }
    },
    plugins: [boundaryAwareValuesPlugin] // Use our boundary-aware plugin
  });
 }



  function initializePerformanceChart() {
    const canvas = document.getElementById('netWorthChart');
    if (!canvas) return;

    const ctx = canvas.getContext('2d');

    // Destroy existing chart
    if (_chart) {
      _chart.destroy();
    }

    // Get performance data for selected year
    const performanceData = calculateMonthlyPerformance(_selectedYear);

    // Always show all 12 months, but use null for months without data (no bar will render)
    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    const allMonthsData = monthNames.map(monthName => {
      const monthData = performanceData.monthlyPercentages.find(d => d.month === monthName);
      if (monthData && monthData.hasData) {
        return monthData.percentage;
      }
      return null; // null = no bar will be rendered for this month
    });

    const labels = monthNames;
    const data = allMonthsData;
    const colors = data.map(val => val === null ? 'transparent' : (val >= 0 ? 'rgba(76, 175, 80, 0.8)' : 'rgba(244, 67, 54, 0.8)'));

    // Calculate actual min and max from the data
    const validData = data.filter(val => val !== null);
    const dataMin = validData.length > 0 ? Math.min(...validData) : 0;
    const dataMax = validData.length > 0 ? Math.max(...validData) : 0;

    // Calculate padding (10% of the range)
    const range = Math.abs(dataMax - dataMin);
    const padding = range > 0 ? range * 0.1 : 1;

    // Apply padding correctly - subtract for min, add for max
    const yMin = dataMin - padding;
    const yMax = dataMax + padding;

    const isMobile = window.innerWidth < 768;

    _chart = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: labels,
        datasets: [{
          label: 'Monthly Performance',
          data: data,
          backgroundColor: colors,
          borderColor: colors.map(c => c.replace('0.8', '1')),
          borderWidth: 2,
          borderRadius: 4
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
          mode: 'index',
          intersect: false
        },
        plugins: {
          legend: {
            display: false
          },
          tooltip: {
            enabled: true,
            backgroundColor: 'rgba(0, 0, 0, 0.8)',
            padding: 12,
            titleFont: {
              size: 13,
              family: 'Lato, sans-serif'
            },
            bodyFont: {
              size: 12,
              family: 'Lato, sans-serif'
            },
            callbacks: {
              label: function(context) {
                const percentage = context.parsed.y;
                return `Performance: ${percentage.toFixed(2)}%`;
              }
            }
          },
          title: {
            display: true,
            text: `${_selectedYear}: ${performanceData.yearlyPerformance.toFixed(2)}%`,
            font: {
              size: isMobile ? 14 : 16,
              weight: 'bold',
              family: 'Lato, sans-serif'
            },
            color: performanceData.yearlyPerformance >= 0 ? '#4caf50' : '#f44336',
            padding: {
              top: 10,
              bottom: 20
            }
          }
        },
        scales: {
          x: {
            grid: {
              display: false,
              drawBorder: false
            },
            ticks: {
              font: {
                size: isMobile ? 10 : 12,
                family: 'Lato, sans-serif'
              },
              padding: isMobile ? 8 : 10
            }
          },
          y: {
            display: true,
            position: 'left',
            min: yMin,
            max: yMax,
            grid: {
              display: false,
              drawBorder: false
            },
            border: {
              display: false
            },
            ticks: {
              callback: function(value, index, ticks) {
                // Only show min, zero, and max values
                if (index === 0 || index === ticks.length - 1) {
                  return value.toFixed(2) + '%';
                }
                // Show zero if it's close to a tick value
                if (Math.abs(value) < 0.01 && dataMin < 0 && dataMax > 0) {
                  return '0.00%';
                }
                return '';
              },
              font: {
                size: isMobile ? 9 : 11,
                family: 'Lato, sans-serif'
              },
              color: '#666'
            }
          }
        },
        layout: {
          padding: {
            bottom: isMobile ? 20 : 25
          }
        }
      },
      plugins: [{
        id: 'performanceLabels',
        afterDraw: function(chart) {
          const ctx = chart.ctx;
          const meta = chart.getDatasetMeta(0);
          const xAxis = chart.scales.x;

          ctx.save();
          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';

          meta.data.forEach((bar, index) => {
            const percentage = data[index];

            // Skip null values (months without data)
            if (percentage === null) return;

            // Show decimals on desktop, whole numbers on mobile
            const label = isMobile
              ? `${Math.round(percentage)}%`
              : `${percentage.toFixed(2)}%`;

            // Position label below the x-axis labels (month names)
            const x = bar.x;
            // xAxis.bottom is where the x-axis labels end, add spacing below that
            const y = xAxis.bottom + (isMobile ? 5 : 8);

            // Bigger font on desktop
            ctx.font = `${isMobile ? '10' : '13'}px Lato, sans-serif`;
            ctx.fillStyle = percentage >= 0 ? '#4caf50' : '#f44336';
            ctx.fillText(label, x, y);
          });

          ctx.restore();
        }
      }]
    });
  }

  function initializeAllocationChart() {
  const canvas = document.getElementById('netWorthChart');
  if (!canvas) return;

  const ctx = canvas.getContext('2d');

  // Destroy existing chart
  if (_chart) {
    _chart.destroy();
  }

  // Get current month entries only
  const currentMonthEntries = getCurrentMonthEntries();

  // Group by asset name and calculate totals
  const assetsByName = {};
  let totalAssets = 0;

  currentMonthEntries.forEach(entry => {
    const category = ASSET_CATEGORIES[entry.asset];
    if (!category || !entry.name) return;

    const amount = parseFloat(entry.amount) || 0;

    // Skip amounts less than 1 for allocation chart
    if (Math.abs(amount) < 1) return;

    // Only include positive values (assets, not debts)
    if (!category.isDebt && amount > 0) {
      if (!assetsByName[entry.name]) {
        assetsByName[entry.name] = {
          name: entry.name,
          amount: 0,
          type: entry.type
        };
      }
      assetsByName[entry.name].amount += amount;
      totalAssets += amount;
    }
  });

    // Convert to array and sort by amount
    const sortedAssets = Object.values(assetsByName)
      .sort((a, b) => b.amount - a.amount);

    // Assign colors to asset names if not already assigned
    assignColorsToAssetNames(sortedAssets);

    // Prepare data for donut chart
    const labels = sortedAssets.map(asset => asset.name);
    const data = sortedAssets.map(asset => (asset.amount / totalAssets) * 100);
    const backgroundColors = sortedAssets.map(asset => _assetNameColors[asset.name]);

    const isMobile = window.innerWidth < 768;

    _chart = new Chart(ctx, {
      type: 'doughnut',
      data: {
        labels: labels,
        datasets: [{
          data: data,
          backgroundColor: backgroundColors,
          borderWidth: 2,
          borderColor: '#fff'
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        cutout: '60%', // Makes it a donut (vs pie)
        layout: {
          padding: {
            top: 20,
            bottom: 20,
            left: 20,
            right: 20
          }
        },
        plugins: {
          legend: {
            display: false // Hide legend, we'll draw labels inside
          },
          tooltip: {
            backgroundColor: 'rgba(0,0,0,0.8)',
            titleColor: '#fff',
            bodyColor: '#fff',
            titleFont: {
              size: 13,
              weight: 'bold',
              family: 'Lato, sans-serif'
            },
            bodyFont: {
              size: 12,
              family: 'Lato, sans-serif'
            },
            padding: 12,
            callbacks: {
              label: function(context) {
                const asset = sortedAssets[context.dataIndex];
                const percentage = data[context.dataIndex].toFixed(1);
                return `${asset.name}: ${formatCurrency(asset.amount)} (${percentage}%)`;
              }
            }
          }
        }
      },
      plugins: [{
        id: 'donutLabels',
        afterDraw: function(chart) {
          const ctx = chart.ctx;
          const chartArea = chart.chartArea;
          const centerX = (chartArea.left + chartArea.right) / 2;
          const centerY = (chartArea.top + chartArea.bottom) / 2;

          ctx.save();
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          chart.data.datasets[0].data.forEach((value, index) => {
            const meta = chart.getDatasetMeta(0);
            const arc = meta.data[index];

            // Calculate position for label (between center and edge of donut)
            const angle = (arc.startAngle + arc.endAngle) / 2;
            const radius = (arc.innerRadius + arc.outerRadius) / 2;
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;

            // Only show label if segment is large enough
            if (value > 5) {
              const label = labels[index];
              const percentage = `${Math.round(value)}%`;

              // Draw asset name
              ctx.font = `bold ${isMobile ? '10' : '12'}px Lato, sans-serif`;
              ctx.fillStyle = '#fff';
              ctx.strokeStyle = 'rgba(0,0,0,0.5)';
              ctx.lineWidth = 3;
              ctx.strokeText(label, x, y - (isMobile ? 8 : 10));
              ctx.fillText(label, x, y - (isMobile ? 8 : 10));

              // Draw percentage
              ctx.font = `${isMobile ? '9' : '11'}px Lato, sans-serif`;
              ctx.strokeText(percentage, x, y + (isMobile ? 6 : 8));
              ctx.fillText(percentage, x, y + (isMobile ? 6 : 8));
            }
          });

          ctx.restore();
        }
      }]
    });
  }
  
  function updateChartTimespan(timespan) {
    _chartTimespan = timespan;
    
    // Update button states
    document.querySelectorAll('.nw-timespan-btn').forEach(btn => {
      btn.classList.remove('active');
      if (btn.getAttribute('data-timespan') === timespan) {
        btn.classList.add('active');
      }
    });
    
    // Recreate chart with new data
    initializeChart();
  }
  
  function renderAssetDetailsModal() {
    return `
      <div class="nw-asset-modal" id="assetDetailsModal" style="display: none;">
        <div class="nw-modal-overlay" id="modalOverlay"></div>
        <div class="nw-modal-content">
          <div class="nw-modal-header">
            <h3 data-translate="asset_details">Asset Details</h3>
            <button class="nw-modal-close" id="modalClose">&times;</button>
          </div>
          <div class="nw-modal-body">
            <div class="nw-modal-form">
              <!-- Top row: Details | Chart | Notes -->
              <div class="nw-modal-top-row">
                <div class="nw-modal-fields-column">
                  <div class="nw-field-group">
                    <label for="assetName" data-translate="name_label">Name</label>
                    <input type="text" id="assetName" class="nw-form-input">
                  </div>
                  <div class="nw-field-group">
                    <label for="assetCategory" data-translate="category_label">Category</label>
                    <input type="text" id="assetCategory" class="nw-form-input">
                    <div class="nw-autocomplete-container"></div>
                  </div>
                  <div class="nw-field-group">
                    <label for="assetAmount" data-translate="amount_label">Amount</label>
                    <div class="nw-amount-input">
                      <span class="nw-currency-symbol" id="assetCurrencySymbol"></span>
                      <input type="number" id="assetAmount" class="nw-form-input" inputmode="decimal">
                    </div>
                  </div>
                </div>
                <div class="nw-modal-chart" id="assetChartSection">
                  <canvas id="assetHistoryChart" height="110"></canvas>
                </div>
                <div class="nw-modal-notes-column">
                  <textarea id="assetNotes" class="nw-form-textarea" placeholder="Add notes..."></textarea>
                </div>
              </div>

              <!-- Collapsible Goal Section (Liquid Assets & Debts only) -->
              <div class="nw-goal-section" id="assetGoalSection" style="display: none;">
                <button type="button" class="nw-goal-toggle" id="goalToggleBtn">
                  <span class="nw-goal-toggle-icon"></span>
                  <span class="nw-goal-toggle-text" id="goalToggleText">Savings Goal</span>
                </button>
                <div class="nw-goal-content" id="goalContent">
                  <div class="nw-goal-fields">
                    <div class="nw-field-group">
                      <label for="assetGoalTarget">Target</label>
                      <div class="nw-amount-input">
                        <span class="nw-currency-symbol" id="goalCurrencySymbol"></span>
                        <input type="number" id="assetGoalTarget" class="nw-form-input" inputmode="decimal" placeholder="0">
                      </div>
                    </div>
                    <div class="nw-field-group">
                      <label for="assetGoalStart">Start</label>
                      <input type="month" id="assetGoalStart" class="nw-form-input">
                    </div>
                    <div class="nw-field-group">
                      <label for="assetGoalEnd">End</label>
                      <input type="month" id="assetGoalEnd" class="nw-form-input">
                    </div>
                    <div class="nw-field-group">
                      <label>Status</label>
                      <div class="nw-goal-status" id="goalStatus">
                        <span class="nw-goal-status-icon"></span>
                        <span class="nw-goal-status-text"></span>
                      </div>
                    </div>
                  </div>
                  <div class="nw-goal-progress-row" id="goalProgressRow">
                    <div class="nw-goal-progress-info">
                      <span class="nw-goal-progress-text" id="goalProgressText">€0 / €0</span>
                      <span class="nw-goal-progress-percent" id="goalProgressPercent">0%</span>
                    </div>
                    <div class="nw-goal-progress-bar">
                      <div class="nw-goal-progress-fill" id="goalProgressFill"></div>
                    </div>
                    <button type="button" class="nw-goal-clear-btn" id="goalClearBtn">Clear Goal</button>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="nw-modal-footer nw-edit-footer">
            <button class="nw-btn-delete" id="deleteAssetBtn" data-translate="delete">Delete</button>
            <button class="nw-btn-cancel" id="cancelAssetBtn" data-translate="cancel">Cancel</button>
            <button class="nw-btn-save" id="saveAssetBtn" data-translate="save">Save</button>
          </div>
        </div>
      </div>
    `;
  }

  function calculateTotalNetWorth() {
    const currentMonthEntries = getCurrentMonthEntries();
    let totalAssets = 0;
    let totalDebts = 0;

    currentMonthEntries.forEach(entry => {
      const category = ASSET_CATEGORIES[entry.asset];
      if (!category) return;

      const amount = parseFloat(entry.amount) || 0;
      if (Math.abs(amount) < 1) return;

      if (category.isDebt) {
        totalDebts += Math.abs(amount);
      } else {
        totalAssets += amount;
      }
    });

    return totalAssets - totalDebts;
  }

  function renderNetWorthView() {
    const container = getElement('netWorthContent');
    if (!container) return;

    const currentMonthEntries = getCurrentMonthEntries();

    // Use summary data from _netWorthData (with safety check)
    const summaryData = _netWorthData.summary || {};
    const summary = {
      totalNetWorth: summaryData.totalNetWorth || 0,
      totalAssets: summaryData.totalAssets || 0,
      totalDebts: summaryData.totalDebts || 0,
      change: summaryData.change || 0
    };

    container.innerHTML = `
      <div class="nw-message" id="netWorthMessage" style="display: none;"></div>

      ${renderNetWorthChart(summary)}

      <div class="nw-categories-grid">
        ${Object.keys(ASSET_CATEGORIES).map(categoryKey =>
          renderCategorySection(categoryKey, currentMonthEntries)
        ).join('')}
      </div>

      ${renderAssetDetailsModal()}
    `;
    
    // Apply translations to the dynamically created content
    if (window.SimBudget && SimBudget.applyTranslations) {
      SimBudget.applyTranslations();
    }

    setupSummaryObserver();

    // Initialize chart after DOM is ready (only if expanded)
    setTimeout(() => {
      if (!_chartCollapsed) {
        initializeChart();
      }
      bindEventHandlers();
      updateChartModeUI();
    }, 100);

    updateMonthYearDisplay();
  }
  
  function setupSummaryObserver() {
    const summaryElement = document.querySelector('.nw-chart-header');
    const bannerSummary = document.getElementById('netWorthBannerSummary');

    if (!bannerSummary) {
      return;
    }

    if (!summaryElement) {
      if (window._netWorthSummaryObserver) {
        window._netWorthSummaryObserver.disconnect();
        window._netWorthSummaryObserver = null;
      }
      return;
    }

    bannerSummary.classList.add('hidden');

    if (window._netWorthSummaryObserver) {
      window._netWorthSummaryObserver.disconnect();
    }

    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting && entry.intersectionRatio > 0.5) {
            bannerSummary.classList.add('hidden');
          } else {
            bannerSummary.classList.remove('hidden');
          }
        });
      },
      { threshold: [0, 0.5] }
    );

    observer.observe(summaryElement);
    window._netWorthSummaryObserver = observer;
  }
  
  function renderCategorySection(categoryKey, allEntries) {
    const category = ASSET_CATEGORIES[categoryKey];
    const entries = allEntries.filter(entry => entry.asset === categoryKey);
    
    // Calculate category total and change
    const categoryTotal = calculateCategoryTotal(categoryKey);
    const categoryChange = calculateCategoryChange(categoryKey);
    
    // Format total for badge (show negative for debts)
    const formattedTotal = category.isDebt && categoryTotal > 0 
      ? `-${formatCurrency(categoryTotal)}` 
      : formatCurrency(Math.abs(categoryTotal));
    
    // Create combined badge with total and change
    const badgeClass = category.isDebt ? 'nw-total-badge-debt' : 'nw-total-badge-asset';
    let totalsDisplay = '';
    
    if (categoryChange !== 0) {
      const arrow = categoryChange > 0 ? '▲' : '▼';
      // For debts, increasing is bad (red), decreasing is good (green)
      // For assets, increasing is good (green), decreasing is bad (red)
      const isPositiveChange = category.isDebt ? categoryChange < 0 : categoryChange > 0;
      const changeClass = isPositiveChange ? 'nw-change-positive' : 'nw-change-negative';

      // Combined badge with total and change
      totalsDisplay = `
        <div class="nw-total-container">
          <span class="${badgeClass}">
            <span class="nw-badge-total">${formattedTotal}</span>
            <span class="nw-badge-change ${changeClass}">${formatCurrency(Math.abs(categoryChange))} ${arrow}</span>
          </span>
        </div>
      `;
    } else {
      // Just the total badge when no change
      totalsDisplay = `
        <div class="nw-total-container">
          <span class="${badgeClass}">
            <span class="nw-badge-total">${formattedTotal}</span>
          </span>
        </div>
      `;
    }
    
    const sectionClass = category.isDebt ? 'nw-section nw-section-debt' : 'nw-section';

    return `
      <div class="${sectionClass}">
        <div class="nw-section-header">
          <div class="nw-section-title-container">
            <h3 class="nw-section-title">${Utils.translateCategory(category.name)}</h3>
            <div class="nw-totals-display">${totalsDisplay}</div>
          </div>
          <div class="nw-header-controls">
            <button class="nw-add-btn" data-category="${categoryKey}">
              <i class="material-icons">add</i> <span data-translate="add">Add</span>
            </button>
          </div>
        </div>
        ${renderAssetTable(categoryKey, entries)}
      </div>
    `;
  }
  
  function sortEntries(entries, categoryKey) {
    const previousMonthEntries = getPreviousMonthEntries();
    const sort = getCategorySort(categoryKey);

    return [...entries].sort((a, b) => {
      let aVal, bVal;

      switch (sort.column) {
        case 'type':
          aVal = (a.type || '').toLowerCase();
          bVal = (b.type || '').toLowerCase();
          break;
        case 'name':
          aVal = (a.name || '').toLowerCase();
          bVal = (b.name || '').toLowerCase();
          break;
        case 'amount':
          aVal = parseFloat(a.amount) || 0;
          bVal = parseFloat(b.amount) || 0;
          break;
        case 'change':
          const aPrev = previousMonthEntries.find(e => e.asset === a.asset && e.name === a.name);
          const bPrev = previousMonthEntries.find(e => e.asset === b.asset && e.name === b.name);
          aVal = (parseFloat(a.amount) || 0) - (aPrev ? parseFloat(aPrev.amount) || 0 : 0);
          bVal = (parseFloat(b.amount) || 0) - (bPrev ? parseFloat(bPrev.amount) || 0 : 0);
          break;
        default:
          return 0;
      }

      if (aVal < bVal) return sort.direction === 'asc' ? -1 : 1;
      if (aVal > bVal) return sort.direction === 'asc' ? 1 : -1;
      return 0;
    });
  }

  function handleSortClick(column, categoryKey) {
    const currentSort = getCategorySort(categoryKey);
    if (currentSort.column === column) {
      currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
    } else {
      currentSort.column = column;
      currentSort.direction = 'asc';
    }
    _categorySort[categoryKey] = currentSort;
    localStorage.setItem('nwCategorySort', JSON.stringify(_categorySort));
    renderNetWorthView();
  }

  function renderAssetTable(categoryKey, entries) {
    if (entries.length === 0) {
      return `
        <div class="nw-empty-state">
          <p>No ${categoryKey.toLowerCase()} found. Click ${Utils.translateCategory('add')} to create one.</p>
        </div>
      `;
    }

    const category = ASSET_CATEGORIES[categoryKey];
    const sortedEntries = sortEntries(entries, categoryKey);
    const sort = getCategorySort(categoryKey);

    const getSortIndicator = (col) => {
      return '';
    };

    return `
      <div class="nw-table-container">
        <table class="nw-table" data-category="${categoryKey}">
          <thead>
            <tr>
              <th class="nw-sortable" data-sort="type" data-category="${categoryKey}">${Utils.translateCategory('category', 'Category')}${getSortIndicator('type')}</th>
              <th class="nw-sortable" data-sort="name" data-category="${categoryKey}">${Utils.translateCategory('name', 'Name')}${getSortIndicator('name')}</th>
              <th class="nw-sortable" data-sort="amount" data-category="${categoryKey}">${Utils.translateCategory('amount', 'Amount')}${getSortIndicator('amount')}</th>
              <th class="nw-sortable" data-sort="change" data-category="${categoryKey}">${Utils.translateCategory('change', 'Change')}${getSortIndicator('change')}</th>
            </tr>
          </thead>
          <tbody>
            ${sortedEntries.map(entry => renderTableRow(entry, category)).join('')}
          </tbody>
        </table>
      </div>
    `;
  }
  
  function renderTableRow(entry, category) {
    // Calculate change from previous month
    const previousMonthEntries = getPreviousMonthEntries();
    const previousEntry = previousMonthEntries.find(e => 
      e.asset === entry.asset && e.name === entry.name
    );
    
    const currentAmount = parseFloat(entry.amount) || 0;
    const previousAmount = previousEntry ? (parseFloat(previousEntry.amount) || 0) : 0;
    const change = currentAmount - previousAmount;
    
    // Format amount
    const formattedAmount = formatCurrency(currentAmount);
    
    // Format change with color and arrow
    // For debts: increase is bad (red), decrease is good (green)
    // For assets: increase is good (green), decrease is bad (red)
    let changeDisplay = '';
    if (previousEntry && change !== 0) {
      const isDebt = category && category.isDebt;
      const isPositiveChange = isDebt ? change < 0 : change > 0;
      const changeClass = isPositiveChange ? 'nw-positive-change' : 'nw-negative-change';
      const arrow = change > 0 ? '▲' : '▼';
      changeDisplay = `<span class="${changeClass}">${formatCurrency(Math.abs(change))} ${arrow}</span>`;
    } else if (!previousEntry) {
      changeDisplay = '<span class="nw-new-entry">New</span>';
    } else {
      changeDisplay = '';
    }
    
    // Add class for zero-value entries
    const zeroValueClass = currentAmount === 0 ? 'nw-zero-value' : '';
    
    return `
      <tr data-id="${entry.id}" data-category="${entry.asset}" class="${zeroValueClass}">
        <td class="nw-type-cell">
          <div class="nw-clickable-name" data-id="${entry.id}" style="cursor: pointer;">
            ${entry.type || ''}
          </div>
        </td>
        <td class="nw-name-cell">
          <div class="nw-clickable-name" data-id="${entry.id}" style="cursor: pointer;">
            ${entry.name || ''}
          </div>
        </td>
        <td class="nw-value-cell">
          <div class="nw-editable" data-field="amount" data-id="${entry.id}">
            ${formattedAmount}
          </div>
        </td>
        <td class="nw-change-cell">
          ${changeDisplay}
        </td>
      </tr>
    `;
  }
  
  function bindEventHandlers() {
  // Chart toggle button
  const chartToggleBtn = document.getElementById('nwChartToggleBtn');
  if (chartToggleBtn) {
    chartToggleBtn.addEventListener('click', function() {
      toggleNwChart();
    });
  }

  // Performance button
  const performanceBtn = document.getElementById('performanceBtn');
  if (performanceBtn) {
    performanceBtn.addEventListener('click', function() {
      if (_chartMode !== 'performance') {
        _chartMode = 'performance';
        updateChartModeUI();
        setTimeout(() => initializeChart(), 10);
      }
    });
  }

  // Timeline button
  const timelineBtn = document.getElementById('timelineBtn');
  if (timelineBtn) {
    timelineBtn.addEventListener('click', function() {
      if (_chartMode !== 'timeline') {
        _chartMode = 'timeline';
        updateChartModeUI();
        setTimeout(() => initializeChart(), 10);
      }
    });
  }

  // Allocation button
  const allocationBtn = document.getElementById('allocationBtn');
  if (allocationBtn) {
    allocationBtn.addEventListener('click', function() {
      if (_chartMode !== 'allocation') {
        _chartMode = 'allocation';
        updateChartModeUI();
        setTimeout(() => initializeChart(), 10);
      }
    });
  }

    // Timeline timespan controls
    document.querySelectorAll('#timelineTimespanControls .nw-timespan-btn').forEach(btn => {
      btn.addEventListener('click', function() {
        const timespan = this.getAttribute('data-timespan');
        if (timespan) {
          updateChartTimespan(timespan);
        }
      });
    });

    // Performance year controls
    document.querySelectorAll('#performanceYearControls .nw-timespan-btn[data-year]').forEach(btn => {
      btn.addEventListener('click', function() {
        const year = parseInt(this.getAttribute('data-year'), 10);
        if (year && year !== _selectedYear) {
          _selectedYear = year;

          // Update button states
          document.querySelectorAll('#performanceYearControls .nw-timespan-btn').forEach(b => {
            b.classList.remove('active');
          });
          this.classList.add('active');

          // Re-render chart
          setTimeout(() => initializeChart(), 10);
        }
      });
    });

    // More years toggle button - use event delegation for robustness
    const performanceYearControls = document.getElementById('performanceYearControls');
    if (performanceYearControls) {
      performanceYearControls.addEventListener('click', function(e) {
        const moreBtn = e.target.closest('.nw-more-years-btn');
        if (moreBtn) {
          e.stopPropagation();
          const olderYears = this.querySelectorAll('.nw-older-year');
          const isExpanded = moreBtn.classList.contains('expanded');

          olderYears.forEach(btn => {
            btn.style.display = isExpanded ? 'none' : '';
          });

          moreBtn.classList.toggle('expanded');
          moreBtn.textContent = isExpanded ? '...' : '‹';
          moreBtn.title = isExpanded ? 'Show earlier years' : 'Hide earlier years';
        }
      });
    }
    
    document.querySelectorAll('.nw-add-btn').forEach(btn => {
      btn.addEventListener('click', function() {
        const category = this.getAttribute('data-category');
        showAddAssetModal(category);
      });
    });
    
    // Remove toggle buttons
    document.querySelectorAll('.nw-remove-toggle').forEach(btn => {
      btn.addEventListener('click', function() {
        _removeMode = !_removeMode;
        
        // Update all remove toggle buttons
        document.querySelectorAll('.nw-remove-toggle').forEach(toggle => {
          if (_removeMode) {
            toggle.setAttribute('data-active', 'true');
          } else {
            toggle.removeAttribute('data-active');
          }
        });
        
        // Show/hide all delete buttons
        document.querySelectorAll('.nw-delete-btn').forEach(deleteBtn => {
          if (_removeMode) {
            deleteBtn.classList.remove('nw-hidden');
          } else {
            deleteBtn.classList.add('nw-hidden');
          }
        });
      });
    });
    
    document.querySelectorAll('.nw-editable').forEach(el => {
      el.addEventListener('click', function() {
        // Don't re-init if already editing
        if (this.hasAttribute('contenteditable') && this.getAttribute('contenteditable') === 'true') {
          return;
        }
        makeFieldEditable(this);
      });
    });
    
    document.querySelectorAll('.nw-notes-btn').forEach(btn => {
      btn.addEventListener('click', function() {
        const id = this.getAttribute('data-id');
        showNotesModal(id);
      });
    });
    
    document.querySelectorAll('.nw-delete-btn').forEach(btn => {
      btn.addEventListener('click', function() {
        const id = this.getAttribute('data-id');
        deleteEntry(id);
      });
    });
    
    // Clickable asset names
    document.querySelectorAll('.nw-clickable-name').forEach(nameElement => {
      nameElement.addEventListener('click', function() {
        const id = this.getAttribute('data-id');
        showAssetDetailsModal(id);
      });
    });

    // Sortable column headers
    document.querySelectorAll('.nw-sortable').forEach(header => {
      header.addEventListener('click', function() {
        const column = this.getAttribute('data-sort');
        const categoryKey = this.getAttribute('data-category');
        handleSortClick(column, categoryKey);
      });
    });
  }
  
  function makeFieldEditable(element) {
    const field = element.getAttribute('data-field');
    const id = element.getAttribute('data-id');
    
    const entry = _netWorthData.entries.find(e => e.id === id);
    if (!entry) return;
    
    let currentValue;
    let isNumericField = false;
    
    switch(field) {
      case 'type':
        currentValue = entry.type || '';
        break;
      case 'name':
        currentValue = entry.name || '';
        break;
      case 'amount':
        currentValue = entry.amount;
        isNumericField = true;
        break;
      default:
        return;
    }
    
    const originalContent = element.innerHTML;

    if (isNumericField) {
      // Use contenteditable for better editing experience (select portions, etc.)
      const currencySymbol = getCurrencySymbol();
      element.innerHTML = `<span class="nw-edit-currency-inline">${currencySymbol}</span>${currentValue}`;
      element.setAttribute('contenteditable', 'true');
      element.classList.add('nw-editing');
      element.setAttribute('inputmode', 'decimal');
      element.focus();

      // Select only the number part (after currency symbol)
      const text = element.textContent;
      const match = text.match(/[\d.,]/);
      if (match) {
        const numberStart = text.indexOf(match[0]);
        const range = document.createRange();
        const textNode = element.lastChild; // The number is in the last text node
        if (textNode && textNode.nodeType === 3) {
          range.setStart(textNode, 0);
          range.setEnd(textNode, textNode.length);
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);
        }
      }

      // Prevent cursor from going before currency symbol
      const handleKeydown = function(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          element.blur();
          return;
        }

        const selection = window.getSelection();
        if (!selection.rangeCount) return;

        const range = selection.getRangeAt(0);
        const currencySpan = element.querySelector('.nw-edit-currency-inline');
        const currencyLength = currencySpan ? currencySpan.textContent.length : 0;

        // Check if cursor is at the start of the text node (right after currency)
        const textNode = element.lastChild;
        if (textNode && textNode.nodeType === 3) {
          const isAtStart = range.startContainer === textNode && range.startOffset === 0;

          // Prevent backspace from going into currency symbol
          if (e.key === 'Backspace' && isAtStart && range.collapsed) {
            e.preventDefault();
          }

          // Prevent left arrow from going before number
          if (e.key === 'ArrowLeft' && isAtStart && range.collapsed) {
            e.preventDefault();
          }
        }

        // Prevent deleting the currency span
        if (e.key === 'Backspace' || e.key === 'Delete') {
          const currencySpan = element.querySelector('.nw-edit-currency-inline');
          if (currencySpan && selection.containsNode(currencySpan, true)) {
            e.preventDefault();
          }
        }
      };

      const handleBlur = function() {
        element.removeAttribute('contenteditable');
        element.classList.remove('nw-editing');
        element.removeEventListener('keydown', handleKeydown);
        element.removeEventListener('blur', handleBlur);
        element.removeEventListener('mouseup', handleMouseup);

        // Extract the numeric value
        const text = element.textContent;
        const rawValue = text.replace(/[^0-9.-]+/g, '');
        let newValue = parseFloat(rawValue);

        // Allow 0 values, only reject negative or NaN
        if (isNaN(newValue) || newValue < 0) {
          element.innerHTML = originalContent;
          return;
        }

        // Skip save if value unchanged
        if (newValue === currentValue) {
          element.innerHTML = formatCurrency(newValue);
          return;
        }

        entry.amount = newValue;
        element.innerHTML = formatCurrency(newValue);

        // Show saving indicator
        element.classList.add('nw-saving');

        // Update the row's change cell optimistically
        const row = element.closest('tr');
        if (row) {
          const changeCell = row.querySelector('.nw-change-cell');
          if (changeCell) {
            // Get previous month value for this entry
            const previousMonthEntries = getPreviousMonthEntries();
            const previousEntry = previousMonthEntries.find(e =>
              e.asset === entry.asset && e.name === entry.name
            );
            const previousAmount = previousEntry ? (parseFloat(previousEntry.amount) || 0) : 0;
            const change = newValue - previousAmount;

            if (change !== 0) {
              const category = ASSET_CATEGORIES[entry.asset];
              const isDebt = category && category.isDebt;
              const isPositiveChange = isDebt ? change < 0 : change > 0;
              const changeClass = isPositiveChange ? 'nw-positive-change' : 'nw-negative-change';
              const arrow = change > 0 ? '▲' : '▼';
              changeCell.innerHTML = `<span class="${changeClass}">${formatCurrency(Math.abs(change))} ${arrow}</span>`;
            } else if (!previousEntry) {
              changeCell.innerHTML = '<span class="nw-new-entry">New</span>';
            } else {
              changeCell.innerHTML = '';
            }
          }
        }

        // Save and update summary without full re-render
        saveNetWorthEntries([entry]);
        calculateSummary();

        // Update summary display without full re-render
        updateSummaryDisplay();

        // Update the actual Chart.js chart with new data
        initializeChart();

        // Show saved indicator after a short delay (simulating save completion)
        setTimeout(() => {
          element.classList.remove('nw-saving');
          element.classList.add('nw-saved');
          setTimeout(() => element.classList.remove('nw-saved'), 1000);
        }, 500);
      };

      const handleMouseup = function() {
        const selection = window.getSelection();
        if (!selection.rangeCount) return;

        const range = selection.getRangeAt(0);
        const currencySpan = element.querySelector('.nw-edit-currency-inline');

        // If selection includes currency span, adjust it
        if (currencySpan && selection.containsNode(currencySpan, true)) {
          const textNode = element.lastChild;
          if (textNode && textNode.nodeType === 3) {
            range.setStart(textNode, 0);
            selection.removeAllRanges();
            selection.addRange(range);
          }
        }
      };

      element.addEventListener('keydown', handleKeydown);
      element.addEventListener('blur', handleBlur);
      element.addEventListener('mouseup', handleMouseup);

    } else {
      // Text fields - use regular input
      element.innerHTML = `
        <div class="nw-edit-wrapper">
          <input type="text" class="nw-edit-input nw-text-input" value="${currentValue}" placeholder="Enter ${field}">
        </div>
      `;

      const input = element.querySelector('input');
      input.focus();
      input.select();

      input.addEventListener('blur', function() {
        let newValue = this.value.trim();

        if (!newValue && (field === 'type' || field === 'name')) {
          alert(`${field.charAt(0).toUpperCase() + field.slice(1)} cannot be empty`);
          element.innerHTML = originalContent;
          return;
        }

        switch(field) {
          case 'type':
            entry.type = newValue;
            break;
          case 'name':
            entry.name = newValue;
            break;
        }

        element.innerHTML = newValue;

        saveNetWorthEntries([entry]);

        if (field === 'type') {
          assignColorsToAssetTypes();
          calculateSummary();
          renderNetWorthView();
        } else {
          showSaveIndicator(element);
        }
      });

      input.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
          this.blur();
        }
      });
    }
  }
  
  function showAddAssetModal(categoryKey) {
    const category = ASSET_CATEGORIES[categoryKey];
    
    // Safety check - if category is not found, return early
    if (!category) {
      console.warn('Invalid category key:', categoryKey);
      return;
    }
    
    const container = getElement('netWorthContent');
    if (!container) return;
    
    const backdrop = document.createElement('div');
    backdrop.className = 'nw-modal-backdrop';
    
    const modal = document.createElement('div');
    modal.className = 'nw-modal nw-compact-modal';

    // Set placeholders based on asset type
    const placeholders = {
      'Liquid Assets': { name: 'e.g. Venmo', category: 'e.g. Digital Wallet' },
      'Investments': { name: 'e.g. VGT', category: 'e.g. ETFs' },
      'Physical Assets': { name: 'e.g. House', category: 'e.g. Real Estate' },
      'Debts': { name: 'e.g. House', category: 'e.g. Mortgage' }
    };
    const ph = placeholders[categoryKey] || { name: 'Name', category: 'Category' };

    modal.innerHTML = `
      <div class="nw-modal-header">
        <h3><span data-translate="add">Add</span> ${Utils.translateCategory(category.singularName || category.name)}</h3>
        <button class="nw-modal-close" type="button" aria-label="Close">×</button>
      </div>
      <div class="nw-modal-body">
        <div class="nw-single-col-form">
          <div class="nw-form-field">
            <label data-translate="name">Name</label>
            <input type="text" id="assetName" class="nw-input" placeholder="${ph.name}" required>
          </div>
          <div class="nw-form-field">
            <label data-translate="category">Category</label>
            <div class="nw-autocomplete-wrapper">
              <input type="text" id="assetType" class="nw-input" placeholder="${ph.category}" required>
              <div class="nw-autocomplete-container"></div>
            </div>
          </div>
          <div class="nw-form-field">
            <label data-translate="amount">Amount</label>
            <div class="nw-input-amount">
              <span class="nw-currency">${getCurrencySymbol()}</span>
              <input type="number" id="assetAmount" class="nw-input" placeholder="0.00" step="1" min="0" inputmode="decimal" required>
            </div>
          </div>
          <button type="button" class="nw-add-note-btn" id="addNotesToggleBtn">+ Add Note</button>
          <div class="nw-notes-area" id="addNotesRow" style="display: none;">
            <textarea id="assetNotes" class="nw-input nw-textarea" placeholder="Additional notes..."></textarea>
          </div>
        </div>
      </div>
      <div class="nw-modal-footer">
        <button class="nw-btn-cancel" id="cancelAddAsset" data-translate="cancel">Cancel</button>
        <button class="nw-btn-save" id="saveAddAsset" disabled data-translate="save">Save</button>
      </div>
    `;
    
    container.appendChild(backdrop);
    container.appendChild(modal);
    
    // Apply translations to the dynamically created modal
    if (window.SimBudget && SimBudget.applyTranslations) {
      SimBudget.applyTranslations();
    }
    
    bindModalEvents(modal, backdrop, categoryKey);
  }
  
    function bindModalEvents(modal, backdrop, categoryKey) {
    const container = getElement('netWorthContent');
    const category = ASSET_CATEGORIES[categoryKey];
    
    const typeInput = modal.querySelector('#assetType');
    const nameInput = modal.querySelector('#assetName');
    const amountInput = modal.querySelector('#assetAmount');
    const notesInput = modal.querySelector('#assetNotes');
    const saveBtn = modal.querySelector('#saveAddAsset');
    const cancelBtn = modal.querySelector('#cancelAddAsset');
    
    // Setup autocomplete
    const autocompleteContainer = modal.querySelector('.nw-autocomplete-container');
    setupAutocomplete(typeInput, category.suggestedTypes, autocompleteContainer);
    
    // Validation function
    function validateForm() {
      const isValid = typeInput.value.trim() && 
                     nameInput.value.trim() && 
                     amountInput.value && 
                     parseFloat(amountInput.value) >= 0;
      
      saveBtn.disabled = !isValid;
    }
    
    // Add input listeners for validation
    [typeInput, nameInput, amountInput].forEach(input => {
      input.addEventListener('input', validateForm);
    });
    
    // Prevent invalid characters in amount field
    if (amountInput) {
      const preventInvalidChars = (e) => {
        // Allow: backspace, delete, tab, escape, enter, home, end, left, right, up, down
        if ([8, 9, 27, 13, 46, 35, 36, 37, 38, 39, 40].indexOf(e.keyCode) !== -1 ||
            // Allow Ctrl+A, Ctrl+C, Ctrl+V, Ctrl+X
            (e.keyCode === 65 && e.ctrlKey === true) ||
            (e.keyCode === 67 && e.ctrlKey === true) ||
            (e.keyCode === 86 && e.ctrlKey === true) ||
            (e.keyCode === 88 && e.ctrlKey === true)) {
          return;
        }
        // Ensure that it is a number and stop the keypress
        if ((e.shiftKey || (e.keyCode < 48 || e.keyCode > 57)) && (e.keyCode < 96 || e.keyCode > 105)) {
          e.preventDefault();
        }
        // Prevent 'e', '+', '-' characters
        if (e.key === 'e' || e.key === 'E' || e.key === '+' || e.key === '-') {
          e.preventDefault();
        }
      };
      amountInput.addEventListener('keydown', preventInvalidChars);
    }
    
    // Save function
    function saveAsset() {
      const type = typeInput.value.trim();
      const name = nameInput.value.trim();
      const amount = parseFloat(amountInput.value);
      const notes = notesInput.value.trim();
      
      // Validation with specific messages
      if (!name) {
        showMessage('Please enter a name for the asset', 'error');
        nameInput.focus();
        return;
      }
      
      if (!type) {
        showMessage('Please enter a category for the asset', 'error');
        typeInput.focus();
        return;
      }
      
      if (isNaN(amount) || amount < 0) {
        showMessage('Please enter a valid amount', 'error');
        amountInput.focus();
        return;
      }
      
      // All validations passed, save the asset
      const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      const dateStr = `${monthNames[_currentMonth]} ${_currentYear}`;
      
      const newEntry = {
        id: `new-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
        date: dateStr,
        asset: categoryKey,
        type: type,
        name: name,
        amount: amount,
        notes: notes
      };
      
      _netWorthData.entries.push(newEntry);
      
      // Re-assign colors after adding new entry with new type
      assignColorsToAssetTypes();
      
      calculateSummary();
      renderNetWorthView();
      saveNetWorthEntries([newEntry]);
      
      showMessage(`${type}: ${name} added successfully`, 'success');
      
      // Close modal
      if (container.contains(backdrop)) container.removeChild(backdrop);
      if (container.contains(modal)) container.removeChild(modal);
    }
    
    // Cancel function
    function closeModal() {
      if (container.contains(backdrop)) container.removeChild(backdrop);
      if (container.contains(modal)) container.removeChild(modal);
    }
    
    // Bind events
    saveBtn.addEventListener('click', saveAsset);
    cancelBtn.addEventListener('click', closeModal);

    // Close button (X)
    const closeBtn = modal.querySelector('.nw-modal-close');
    if (closeBtn) {
      closeBtn.addEventListener('click', closeModal);
    }

    // Notes toggle button
    const notesToggleBtn = modal.querySelector('#addNotesToggleBtn');
    const notesRow = modal.querySelector('#addNotesRow');
    if (notesToggleBtn && notesRow) {
      notesToggleBtn.addEventListener('click', function() {
        const isHidden = notesRow.style.display === 'none';
        notesRow.style.display = isHidden ? 'block' : 'none';
        notesToggleBtn.textContent = isHidden ? '− Hide Note' : '+ Add Note';
        if (isHidden && notesInput) {
          notesInput.focus();
        }
      });
    }

    // Add event listener to backdrop for click-outside functionality
    backdrop.addEventListener('click', closeModal);

    // Prevent clicks on the modal itself from closing it
    modal.addEventListener('click', function(e) {
      e.stopPropagation();
    });

    // Enter key saves if form is valid
    modal.addEventListener('keydown', function(e) {
      if (e.key === 'Enter' && !saveBtn.disabled) {
        e.preventDefault();
        saveAsset();
      } else if (e.key === 'Escape') {
        closeModal();
      }
    });

    // Focus first input
    setTimeout(() => nameInput.focus(), 100);
  }
  
  function showAssetDetailsModal(id) {
    const entry = _netWorthData.entries.find(e => e.id === id);
    if (!entry) return;
    
    const modal = document.getElementById('assetDetailsModal');
    if (!modal) return;
    
    // Populate form fields
    document.getElementById('assetName').value = entry.name || '';
    document.getElementById('assetAmount').value = entry.amount || '';
    document.getElementById('assetCurrencySymbol').textContent = getCurrencySymbol();
    document.getElementById('assetNotes').value = entry.notes || '';
    document.getElementById('assetCategory').value = entry.type || '';

    // Goal section (Liquid Assets + Debts only)
    const goalSection = document.getElementById('assetGoalSection');
    const goalToggleBtn = document.getElementById('goalToggleBtn');
    const goalToggleText = document.getElementById('goalToggleText');
    const goalCurrencySymbol = document.getElementById('goalCurrencySymbol');

    if (goalSection) {
      const isGoalEligible = entry.asset === 'Liquid Assets' || entry.asset === 'Debts';
      goalSection.style.display = isGoalEligible ? 'block' : 'none';

      if (isGoalEligible) {
        // Set goal type label based on asset type
        const goalTypeLabel = entry.asset === 'Debts' ? 'Payoff Goal' : 'Savings Goal';
        if (goalToggleText) goalToggleText.textContent = goalTypeLabel;
        if (goalCurrencySymbol) goalCurrencySymbol.textContent = getCurrencySymbol();

        const goalsState = getSavingsGoalsState();
        const goalId = `${entry.asset}|${entry.name}`;
        const goal = (goalsState.goals || []).find(g => g.id === goalId);

        const targetInput = document.getElementById('assetGoalTarget');
        const startInput = document.getElementById('assetGoalStart');
        const endInput = document.getElementById('assetGoalEnd');
        const amountInput = document.getElementById('assetAmount');
        const clearBtn = document.getElementById('goalClearBtn');

        targetInput.value = goal?.target || '';
        startInput.value = goal?.start || '';
        endInput.value = goal?.end || '';

        // Calculate and display status + progress
        const updateGoalUI = () => {
          const currentAmount = parseFloat(amountInput.value) || 0;
          const target = parseFloat(targetInput.value) || 0;
          const start = startInput.value;
          const end = endInput.value;
          updateGoalStatus(currentAmount, target, start, end, entry);
          updateGoalProgress(currentAmount, target, start, end, entry);
        };

        updateGoalUI();

        // Expand section if goal exists, collapse if not
        const hasGoal = goal?.target > 0;
        goalSection.classList.toggle('expanded', hasGoal);

        // Setup toggle button
        if (goalToggleBtn) {
          goalToggleBtn.onclick = () => {
            goalSection.classList.toggle('expanded');
          };
        }

        // Setup clear button
        if (clearBtn) {
          clearBtn.onclick = () => {
            targetInput.value = '';
            startInput.value = '';
            endInput.value = '';
            updateGoalUI();
          };
        }

        // Update UI when fields change
        targetInput.addEventListener('input', updateGoalUI);
        startInput.addEventListener('change', updateGoalUI);
        endInput.addEventListener('change', updateGoalUI);
        amountInput.addEventListener('input', updateGoalUI);
      }
    }
    
    // Store current entry ID for saving
    modal.setAttribute('data-entry-id', id);
    
    // Show modal
    modal.style.display = 'block';
    
    // Bind modal events
    bindAssetDetailsModalEvents(modal, entry);
    
    // Initialize the asset history chart after DOM is ready
    setTimeout(() => {
      initializeAssetHistoryChart(entry);
    }, 50);
    
    // Focus first input
    setTimeout(() => document.getElementById('assetName').focus(), 100);
  }
  
  
  function initializeAssetHistoryChart(currentEntry) {
    try {
      const canvas = document.getElementById('assetHistoryChart');
      const chartSection = document.getElementById('assetChartSection');

      // Show chart section by default, hide if no data
      if (chartSection) {
        chartSection.classList.remove('hidden');
      }
      if (canvas) {
        canvas.style.display = 'block';
      }

      // Check if Chart.js is available
      if (typeof Chart === 'undefined') {
        console.warn('Chart.js not available for asset history');
        showChartFallback();
        return;
      }

      if (!canvas) {
        console.warn('Canvas element not found');
        showChartFallback();
        return;
      }

      // Collect historical data for this asset (last 6 months)
      const historyData = collectAssetHistory(currentEntry);

      // Check if we have enough data (at least 2 months)
      if (historyData.labels.length < 2) {
        showChartFallback();
        return;
      }

      // Destroy existing chart if any
      const existingChart = Chart.getChart(canvas);
      if (existingChart) {
        existingChart.destroy();
      }

      // Create a 6-month bar chart
      const ctx = canvas.getContext('2d');
      new Chart(ctx, {
        type: 'bar',
        data: {
          labels: historyData.labels,
          datasets: [{
            label: currentEntry.name,
            data: historyData.values,
            backgroundColor: 'rgba(52, 152, 219, 0.7)',
            borderColor: '#3498db',
            borderWidth: 1,
            borderRadius: 3,
            barPercentage: 0.7
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return formatCurrency(context.parsed.y);
                }
              }
            }
          },
          scales: {
            x: {
              grid: {
                display: false
              },
              ticks: {
                font: { size: 10 }
              }
            },
            y: {
              beginAtZero: true,
              grid: {
                color: 'rgba(0, 0, 0, 0.05)'
              },
              ticks: {
                font: { size: 10 },
                maxTicksLimit: 4,
                callback: function(value) {
                  // Compact format for small chart
                  if (value >= 1000) {
                    return (value / 1000).toFixed(0) + 'k';
                  }
                  return value;
                }
              }
            }
          }
        }
      });

    } catch (error) {
      console.error('Error creating asset history chart:', error);
      showChartFallback();
    }
  }
  
  function collectAssetHistory(targetEntry) {
    const labels = [];
    const values = [];

    try {
      const cachedData = CacheManager.getNetWorthWithTimestamp();
      if (!cachedData || !cachedData.entries) {
        return { labels, values };
      }

      const entries = cachedData.entries;
      const dateGroups = {};

      // Parse each entry and match by id or name+asset+type
      entries.forEach(entry => {
        const isIdMatch = entry.id === targetEntry.id;
        const isNameMatch = entry.name === targetEntry.name && entry.asset === targetEntry.asset && entry.type === targetEntry.type;
        const hasDateAndAmount = entry.date && entry.amount !== undefined && entry.amount !== null;

        if (hasDateAndAmount && (isIdMatch || isNameMatch)) {
          const monthMap = { 'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6,
                           'Jul': 7, 'Aug': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dec': 12 };
          const [monthStr, yearStr] = entry.date.split(' ');
          const year = parseInt(yearStr);
          const month = monthMap[monthStr];

          if (year && month) {
            const monthKey = `${year}-${String(month).padStart(2, '0')}`;
            if (!dateGroups[monthKey]) {
              dateGroups[monthKey] = entry;
            }
          }
        }
      });

      // Sort by date and take only last 6 months
      const sortedDates = Object.keys(dateGroups).sort();
      const last6Months = sortedDates.slice(-6);

      last6Months.forEach(monthKey => {
        const entry = dateGroups[monthKey];
        const [year, month] = monthKey.split('-');
        // Short month label (e.g., "Sep")
        const monthName = new Date(parseInt(year), parseInt(month) - 1).toLocaleDateString('en-US', { month: 'short' });

        labels.push(monthName);
        values.push(parseFloat(entry.amount) || 0);
      });

    } catch (error) {
      console.error('Error collecting asset history:', error);
    }

    return { labels, values };
  }
  
  function showChartFallback(message) {
    const chartSection = document.getElementById('assetChartSection');
    if (chartSection) {
      chartSection.classList.add('hidden');
    }
  }
  
  function getAllMonthsWithData() {
    const months = [];
    const currentDate = new Date();
    const currentYear = currentDate.getFullYear();
    const currentMonth = currentDate.getMonth();
    
    // Check last 24 months
    for (let i = 0; i < 24; i++) {
      const checkDate = new Date(currentYear, currentMonth - i, 1);
      const year = checkDate.getFullYear();
      const month = checkDate.getMonth();
      const monthKey = `${year}-${String(month + 1).padStart(2, '0')}`;
      
      if (localStorage.getItem(`networth_${monthKey}`)) {
        months.unshift({ month, year });
      }
    }
    
    return months;
  }

  function getHistoricalAmount(entry, monthKey) {
    // Look up the amount for this asset at a specific month (format: YYYY-MM)
    try {
      const cachedData = CacheManager.getNetWorthWithTimestamp();
      if (!cachedData || !cachedData.entries) return null;

      const entries = cachedData.entries;
      const monthMap = { 'Jan': '01', 'Feb': '02', 'Mar': '03', 'Apr': '04', 'May': '05', 'Jun': '06',
                        'Jul': '07', 'Aug': '08', 'Sep': '09', 'Oct': '10', 'Nov': '11', 'Dec': '12' };

      for (const e of entries) {
        const isMatch = (e.id === entry.id) ||
                       (e.name === entry.name && e.asset === entry.asset && e.type === entry.type);

        if (isMatch && e.date) {
          const [monthStr, yearStr] = e.date.split(' ');
          const entryMonthKey = `${yearStr}-${monthMap[monthStr]}`;

          if (entryMonthKey === monthKey) {
            return parseFloat(e.amount) || 0;
          }
        }
      }
    } catch (error) {
      console.error('Error getting historical amount:', error);
    }
    return null;
  }

  function updateGoalStatus(currentAmount, target, start, end, entry) {
    const statusEl = document.getElementById('goalStatus');
    if (!statusEl) return { status: 'none', amount: currentAmount };

    const textEl = statusEl.querySelector('.nw-goal-status-text');
    const isDebt = entry && entry.asset === 'Debts';

    // Remove all status classes
    statusEl.classList.remove('achieved', 'active', 'expired', 'upcoming', 'none');

    // If no target set, show no status
    // For debts, target 0 is valid (payoff goal)
    const hasTarget = isDebt ? (target !== null && target !== undefined && target !== '') : (target && target > 0);
    if (!hasTarget) {
      statusEl.classList.add('none');
      if (textEl) textEl.textContent = '—';
      return { status: 'none', amount: currentAmount };
    }

    // Get current month in YYYY-MM format
    const now = new Date();
    const currentMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;

    // Check dates
    const hasStart = start && start.length > 0;
    const hasEnd = end && end.length > 0;

    // Check if before start date
    if (hasStart && currentMonth < start) {
      statusEl.classList.add('upcoming');
      if (textEl) textEl.textContent = 'Upcoming';
      return { status: 'upcoming', amount: currentAmount };
    }

    // Check if past end date - use historical amount
    if (hasEnd && currentMonth > end) {
      const historicalAmount = entry ? getHistoricalAmount(entry, end) : null;
      const amountAtEnd = historicalAmount !== null ? historicalAmount : currentAmount;

      // For debts: achieved if amount <= target (paid down)
      // For savings: achieved if amount >= target
      const achieved = isDebt ? (amountAtEnd <= target) : (amountAtEnd >= target);

      if (achieved) {
        statusEl.classList.add('achieved');
        if (textEl) textEl.textContent = 'Achieved';
        return { status: 'achieved', amount: amountAtEnd, atDate: end };
      } else {
        statusEl.classList.add('expired');
        if (textEl) textEl.textContent = 'Expired';
        return { status: 'expired', amount: amountAtEnd, atDate: end };
      }
    }

    // Check if achieved
    // For debts: achieved if amount <= target (paid down)
    // For savings: achieved if amount >= target
    const achieved = isDebt ? (currentAmount <= target) : (currentAmount >= target);
    if (achieved) {
      statusEl.classList.add('achieved');
      if (textEl) textEl.textContent = 'Achieved';
      return { status: 'achieved', amount: currentAmount };
    }

    // Within date range and not achieved
    statusEl.classList.add('active');
    if (textEl) textEl.textContent = 'Active';
    return { status: 'active', amount: currentAmount };
  }

  function formatMonthLabel(monthKey) {
    // Convert YYYY-MM to "Jan 2026" format
    if (!monthKey || monthKey.length < 7) return monthKey;
    const [year, month] = monthKey.split('-');
    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    const monthIndex = parseInt(month) - 1;
    return `${monthNames[monthIndex]} ${year}`;
  }

  function updateGoalProgress(currentAmount, target, start, end, entry) {
    const progressRow = document.getElementById('goalProgressRow');
    const progressText = document.getElementById('goalProgressText');
    const progressPercent = document.getElementById('goalProgressPercent');
    const progressFill = document.getElementById('goalProgressFill');
    const statusEl = document.getElementById('goalStatus');
    const isDebt = entry && entry.asset === 'Debts';

    if (!progressRow) return;

    // Hide if no target set
    // For debts, target 0 is valid (payoff goal)
    const hasTarget = isDebt ? (target !== null && target !== undefined && target !== '') : (target && target > 0);
    if (!hasTarget) {
      progressRow.classList.remove('visible');
      return;
    }

    progressRow.classList.add('visible');

    // Determine which amount to show
    let displayAmount = currentAmount;
    let displayLabel = '';

    // Get current month
    const now = new Date();
    const currentMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;

    // If past end date, show historical amount at end date
    const hasEnd = end && end.length > 0;
    if (hasEnd && currentMonth > end && entry) {
      const historicalAmount = getHistoricalAmount(entry, end);
      if (historicalAmount !== null) {
        displayAmount = historicalAmount;
        displayLabel = ` at ${formatMonthLabel(end)}`;
      }
    }

    // Calculate percentage
    let percent;
    if (isDebt) {
      // For debts: progress = how much paid off from start
      // Get starting amount at goal start date
      const hasStart = start && start.length > 0;
      let startingAmount = displayAmount; // fallback to current
      if (hasStart && entry) {
        const historicalStart = getHistoricalAmount(entry, start);
        if (historicalStart !== null) {
          startingAmount = historicalStart;
        }
      }

      // Progress = (startingAmount - currentAmount) / (startingAmount - target) * 100
      // e.g., started at 1000, target 0, now at 200 → (1000-200)/(1000-0) = 80%
      if (displayAmount <= target) {
        percent = 100;
      } else if (startingAmount <= target) {
        percent = 0; // edge case: started below target already
      } else {
        const totalToPayOff = startingAmount - target;
        const paidOff = startingAmount - displayAmount;
        percent = Math.max(0, Math.min(100, Math.round((paidOff / totalToPayOff) * 100)));
      }
    } else {
      percent = Math.min(Math.round((displayAmount / target) * 100), 100);
    }

    // Update text
    if (progressText) {
      progressText.textContent = `${formatCurrency(displayAmount)}${displayLabel} / ${formatCurrency(target)}`;
    }
    if (progressPercent) {
      progressPercent.textContent = `${percent}%`;
    }

    // Update progress bar
    if (progressFill) {
      progressFill.style.width = `${percent}%`;

      // Match color to status
      progressFill.classList.remove('achieved', 'active', 'expired', 'upcoming');
      if (statusEl) {
        if (statusEl.classList.contains('achieved')) progressFill.classList.add('achieved');
        else if (statusEl.classList.contains('active')) progressFill.classList.add('active');
        else if (statusEl.classList.contains('expired')) progressFill.classList.add('expired');
        else if (statusEl.classList.contains('upcoming')) progressFill.classList.add('upcoming');
      }
    }
  }

  function bindAssetDetailsModalEvents(modal, entry) {
    // Clear any existing handlers by storing them and removing them
    if (modal._handlers) {
      modal._handlers.forEach(handler => {
        handler.element.removeEventListener(handler.event, handler.func);
      });
    }
    modal._handlers = [];
    
    // Helper function to add event listener and track it
    function addHandler(element, event, func) {
      element.addEventListener(event, func);
      modal._handlers.push({ element, event, func });
    }
    
    // Setup autocomplete for category field
    const categoryInput = modal.querySelector('#assetCategory');
    const autocompleteContainer = modal.querySelector('.nw-autocomplete-container');
    if (categoryInput && autocompleteContainer && entry.asset) {
      const category = ASSET_CATEGORIES[entry.asset];
      if (category && category.suggestedTypes) {
        setupAutocomplete(categoryInput, category.suggestedTypes, autocompleteContainer);
      }
    }
    
    // Close button
    const closeBtn = modal.querySelector('#modalClose');
    if (closeBtn) {
      addHandler(closeBtn, 'click', () => {
        modal.style.display = 'none';
      });
    }
    
    // Overlay click
    const overlay = modal.querySelector('#modalOverlay');
    if (overlay) {
      addHandler(overlay, 'click', () => {
        modal.style.display = 'none';
      });
    }
    
    // Cancel button
    const cancelBtn = modal.querySelector('#cancelAssetBtn');
    if (cancelBtn) {
      addHandler(cancelBtn, 'click', () => {
        modal.style.display = 'none';
      });
    }
    
    // Save button
    const saveBtn = modal.querySelector('#saveAssetBtn');
    if (saveBtn) {
      addHandler(saveBtn, 'click', () => {
        saveAssetDetailsFromModal(modal);
      });
    }
    
    // Delete button
    const deleteBtn = modal.querySelector('#deleteAssetBtn');
    if (deleteBtn) {
      addHandler(deleteBtn, 'click', () => {
        showDeleteConfirmDialog(entry, 
          () => {
            // Delete directly without calling deleteEntry to avoid double confirmation
            _netWorthData.entries = _netWorthData.entries.filter(e => e.id !== entry.id);
            assignColorsToAssetTypes();
            calculateSummary();
            renderNetWorthView();
            modal.style.display = 'none';
            
            // Delete from Google Sheet
            if (window.API && typeof API.clearNetWorthRow === 'function') {
              API.clearNetWorthRow(entry.id, function(result) {
                if (result && result.success) {
                  // ✅ UPDATE CACHE WITH CURRENT TIMESTAMP
                  if (window.CacheManager && typeof CacheManager.setNetWorthWithTimestamp === 'function') {
                    const cached = CacheManager.getNetWorthWithTimestamp();
                    const goals = cached && Array.isArray(cached.goals) ? cached.goals : [];
                    const timestamp = result.timestamp || new Date().toISOString();
                    CacheManager.setNetWorthWithTimestamp({ entries: _netWorthData.entries, goals: goals }, timestamp);
                  }
                }
              });
            }
          },
          () => {
            // Do nothing on cancel
          }
        );
      });
    }
    
    // Keyboard events
    const keydownHandler = (e) => {
      if (e.key === 'Escape') {
        modal.style.display = 'none';
      }
    };
    addHandler(modal, 'keydown', keydownHandler);
    
    // Prevent invalid characters in amount field
    const amountInput = modal.querySelector('#assetAmount');
    if (amountInput) {
      const preventInvalidChars = (e) => {
        // Allow: backspace, delete, tab, escape, enter, home, end, left, right, up, down
        if ([8, 9, 27, 13, 46, 35, 36, 37, 38, 39, 40].indexOf(e.keyCode) !== -1 ||
            // Allow Ctrl+A, Ctrl+C, Ctrl+V, Ctrl+X
            (e.keyCode === 65 && e.ctrlKey === true) ||
            (e.keyCode === 67 && e.ctrlKey === true) ||
            (e.keyCode === 86 && e.ctrlKey === true) ||
            (e.keyCode === 88 && e.ctrlKey === true)) {
          return;
        }
        // Ensure that it is a number and stop the keypress
        if ((e.shiftKey || (e.keyCode < 48 || e.keyCode > 57)) && (e.keyCode < 96 || e.keyCode > 105)) {
          e.preventDefault();
        }
        // Prevent 'e', '+', '-' characters
        if (e.key === 'e' || e.key === 'E' || e.key === '+' || e.key === '-') {
          e.preventDefault();
        }
      };
      addHandler(amountInput, 'keydown', preventInvalidChars);
    }
  }
  
  function saveAssetDetailsFromModal(modal) {
    const entryId = modal.getAttribute('data-entry-id');
    const entry = _netWorthData.entries.find(e => e.id === entryId);
    if (!entry) return;
    
    // Get form values
    const name = document.getElementById('assetName').value.trim();
    const amount = document.getElementById('assetAmount').value.trim();
    const notes = document.getElementById('assetNotes').value.trim();
    const category = document.getElementById('assetCategory').value.trim();

    // Goal fields
    const goalTarget = parseFloat(document.getElementById('assetGoalTarget')?.value) || 0;
    const goalStart = document.getElementById('assetGoalStart')?.value || '';
    const goalEnd = document.getElementById('assetGoalEnd')?.value || '';
    
    // Validate
    if (!name) {
      showMessage('Please enter a name for the asset', 'error');
      document.getElementById('assetName').focus();
      return;
    }
    
    if (!category) {
      showMessage('Please enter a category for the asset', 'error');
      document.getElementById('assetCategory').focus();
      return;
    }
    
    if (!amount || isNaN(parseFloat(amount)) || parseFloat(amount) < 0) {
      showMessage('Please enter a valid amount', 'error');
      document.getElementById('assetAmount').focus();
      return;
    }
    
    // Update entry
    entry.name = name;
    entry.amount = parseFloat(amount);
    entry.notes = notes;
    entry.type = category;

    if (entry.asset === 'Liquid Assets' || entry.asset === 'Debts') {
      const goalsState = getSavingsGoalsState();
      const goals = Array.isArray(goalsState.goals) ? goalsState.goals.slice() : [];
      const goalId = `${entry.asset}|${name}`;
      const nextGoal = {
        id: goalId,
        asset: entry.asset,
        account: name,
        target: goalTarget,
        start: goalStart,
        end: goalEnd
      };

      const index = goals.findIndex(g => g.id === goalId);
      // For debts, target 0 is valid (payoff goal). For savings, target must be > 0
      const isDebt = entry.asset === 'Debts';
      const hasValidTarget = isDebt
        ? (nextGoal.target !== null && nextGoal.target !== undefined && nextGoal.target !== '' && !isNaN(nextGoal.target))
        : (nextGoal.target > 0);

      if (hasValidTarget) {
        if (index >= 0) {
          goals[index] = nextGoal;
        } else {
          goals.push(nextGoal);
        }
      } else if (index >= 0) {
        goals.splice(index, 1);
      }

      saveSavingsGoalsState({ goals });
    }
    
    // Save goals + entries and refresh
    saveNetWorthEntries(_netWorthData.entries);
    renderNetWorthView();
    modal.style.display = 'none';
    
    showMessage(getTranslation('asset_updated_successfully'), 'success');
  }

  function getSavingsGoalsState() {
    if (window.CacheManager && typeof CacheManager.getNetWorthWithTimestamp === 'function') {
      const cached = CacheManager.getNetWorthWithTimestamp();
      if (cached && Array.isArray(cached.goals)) {
        return { goals: cached.goals };
      }
    }
    return { goals: [] };
  }

  function saveSavingsGoalsState(state) {
    const goals = Array.isArray(state?.goals) ? state.goals : [];

    if (window.API && typeof API.saveNetWorthGoals === 'function') {
      API.saveNetWorthGoals({ goals: goals }, function(result) {
        if (window.CacheManager && typeof CacheManager.setNetWorthWithTimestamp === 'function') {
          const cached = CacheManager.getNetWorthWithTimestamp();
          const entries = cached && Array.isArray(cached.entries) ? cached.entries : _netWorthData.entries;
          const timestamp = result && result.timestamp ? result.timestamp : new Date().toISOString();
          CacheManager.setNetWorthWithTimestamp({ entries: entries, goals: goals }, timestamp);
        }
      }, function(error) {
        console.error('NetWorthManager: Error saving goals:', error);
        showMessage(getTranslation('error_saving_data') + error, 'error');
      });
    }
  }
  
  function showNotesModal(id) {
    const entry = _netWorthData.entries.find(e => e.id === id);
    if (!entry) return;
    
    const container = getElement('netWorthContent');
    if (!container) return;
    
    const backdrop = document.createElement('div');
    backdrop.className = 'nw-modal-backdrop';
    
    const modal = document.createElement('div');
    modal.className = 'nw-modal nw-notes-modal';
    
    modal.innerHTML = `
      <div class="nw-modal-header">
        <h3>Notes for ${entry.name}</h3>
      </div>
      <div class="nw-modal-body">
        <textarea class="nw-input nw-textarea" id="assetNotes" rows="5">${entry.notes || ''}</textarea>
      </div>
    `;
    
    container.appendChild(backdrop);
    container.appendChild(modal);
    
    const textarea = modal.querySelector('#assetNotes');
    textarea.focus();
    
    function closeAndSave() {
      const notes = textarea.value;
      if (notes !== entry.notes) {
        entry.notes = notes;
        saveNetWorthEntries([entry]);
        showMessage(getTranslation('notes_saved'), 'success');
      }
      
      if (container.contains(backdrop)) container.removeChild(backdrop);
      if (container.contains(modal)) container.removeChild(modal);
    }
    
    backdrop.addEventListener('click', closeAndSave);
    
    document.addEventListener('keydown', function handleEsc(e) {
      if (e.key === 'Escape') {
        closeAndSave();
        document.removeEventListener('keydown', handleEsc);
      }
    });
  }
  
  function showDeleteConfirmDialog(entry, onConfirm, onCancel) {
    const container = getElement('netWorthContent');
    if (!container) return;
    
    const backdrop = document.createElement('div');
    backdrop.className = 'nw-modal-backdrop';
    
    const modal = document.createElement('div');
    modal.className = 'nw-modal nw-notes-modal';
    
    modal.innerHTML = `
      <div class="nw-modal-header">
        <h3 data-translate="confirm_delete">Confirm Delete</h3>
        <button class="nw-modal-close">&times;</button>
      </div>
      <div class="nw-modal-body">
        <p>${Utils.translateCategory('are_you_sure_delete').replace('{name}', entry.name)}</p>
      </div>
      <div class="nw-modal-footer">
        <button class="nw-add-btn nw-add-cancel-btn" id="cancelDelete" data-translate="cancel_button">Cancel</button>
        <button class="nw-add-btn nw-add-delete-btn" id="confirmDelete" data-translate="delete_button">Delete</button>
      </div>
    `;
    
    container.appendChild(backdrop);
    container.appendChild(modal);
    
    function closeModal() {
      if (container.contains(backdrop)) container.removeChild(backdrop);
      if (container.contains(modal)) container.removeChild(modal);
      if (onCancel) onCancel();
    }
    
    const closeBtn = modal.querySelector('.nw-modal-close');
    const cancelBtn = modal.querySelector('#cancelDelete');
    
    // Stop propagation to prevent triggering other click handlers
    modal.addEventListener('click', function(e) {
      e.stopPropagation();
    });
    
    closeBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      closeModal();
    });
    
    cancelBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      closeModal();
    });
    
    backdrop.addEventListener('click', function(e) {
      e.stopPropagation();
      closeModal();
    });
    
    modal.querySelector('#confirmDelete').addEventListener('click', function(e) {
      e.stopPropagation();
      closeModal();
      if (onConfirm) onConfirm();
    });
  }
  
        function deleteEntry(id) {
      const entry = _netWorthData.entries.find(e => e.id === id);
      if (!entry) return;
      
      showDeleteConfirmDialog(entry, function() {
        _netWorthData.entries = _netWorthData.entries.filter(e => e.id !== id);
        assignColorsToAssetTypes();
        calculateSummary();
        renderNetWorthView();
        
        if (window.API && typeof API.clearNetWorthRow === 'function') {
          API.clearNetWorthRow(id, function(result) {
            if (result && result.success) {
              // ✅ UPDATE CACHE WITH CURRENT TIMESTAMP
              if (window.CacheManager && typeof CacheManager.setNetWorthWithTimestamp === 'function') {
                const cached = CacheManager.getNetWorthWithTimestamp();
                const goals = cached && Array.isArray(cached.goals) ? cached.goals : [];
                const currentTimestamp = result.timestamp || new Date().toISOString();
                CacheManager.setNetWorthWithTimestamp({ entries: _netWorthData.entries, goals: goals }, currentTimestamp);
              }
            }
          }, function(error) {
            console.error('NetWorthManager: Error deleting entry:', error);
            showMessage(getTranslation('error_deleting_data') + error, 'error');
          });
        }
        
        showMessage(getTranslation('item_removed_successfully').replace('{name}', entry.name), 'success');
      });
    }
  
    function saveNetWorthEntries(entries) {
    if (!window.API || typeof API.saveBatchNetWorth !== 'function') {
      console.warn('NetWorthManager: API.saveBatchNetWorth not available');
      return;
    }
    
    API.saveBatchNetWorth(entries, function(result) {
  if (result && result.success) {
    // Update IDs for new entries if needed
    if (result.entries && entries.length > 0) {
      result.entries.forEach(serverEntry => {
        const localIndex = _netWorthData.entries.findIndex(e => 
          e.asset === serverEntry.asset && 
          e.name === serverEntry.name && 
          e.date === serverEntry.date);
          
        if (localIndex >= 0) {
          _netWorthData.entries[localIndex].id = serverEntry.id;
        }
      });
    }
    
    // ✅ UPDATE CACHE WITH CURRENT TIMESTAMP
    if (window.CacheManager && typeof CacheManager.setNetWorthWithTimestamp === 'function') {
      const cached = CacheManager.getNetWorthWithTimestamp();
      const goals = cached && Array.isArray(cached.goals) ? cached.goals : [];
      const currentTimestamp = result.timestamp || new Date().toISOString();
      CacheManager.setNetWorthWithTimestamp({ entries: _netWorthData.entries, goals: goals }, currentTimestamp);
    }
      }
    }, function(error) {
      console.error('NetWorthManager: Error saving entries:', error);
      showMessage(getTranslation('error_saving_data') + error, 'error');
    });
  }
  
  function showSaveIndicator(element) {
    element.classList.add('nw-saving');
    
    setTimeout(() => {
      element.classList.remove('nw-saving');
      element.classList.add('nw-saved');
      
      setTimeout(() => {
        element.classList.remove('nw-saved');
      }, 1000);
    }, 500);
  }
  
  function showMessage(message, type = 'info') {
    // Use Utils.showToast if available (preferred - doesn't shift DOM)
    if (window.Utils && typeof Utils.showToast === 'function') {
      Utils.showToast(message, type);
      return;
    }

    // Fallback to old method if Utils not available
    const messageContainer = getElement('netWorthMessage');
    if (!messageContainer) return;

    messageContainer.textContent = message;
    messageContainer.className = `nw-message nw-${type}-message`;
    messageContainer.style.display = 'block';

    setTimeout(() => {
      messageContainer.style.display = 'none';
    }, 3000);
  }
  
  function getCurrencySymbol() {
    if (typeof Utils !== 'undefined' && Utils.getCurrencySymbol) {
      return Utils.getCurrencySymbol();
    }
    
    if (typeof SimBudget !== 'undefined' && SimBudget.Settings && SimBudget.Settings.getCurrencySymbol) {
      return SimBudget.Settings.getCurrencySymbol();
    }
    
    return '$';
  }
  
  function formatCurrency(amount) {
    // Handle null/undefined/empty values
    if (amount === null || amount === undefined || amount === '') {
      amount = 0;
    }
    
    // Ensure it's a number
    amount = parseFloat(amount) || 0;
    
    if (typeof Utils !== 'undefined' && Utils.formatCurrency) {
      return Utils.formatCurrency(amount);
    }
    
    const symbol = getCurrencySymbol();
    const absAmount = Math.abs(amount);
    return `${symbol}${absAmount.toLocaleString('en-US', {
      minimumFractionDigits: 0, 
      maximumFractionDigits: 0
    })}`;
  }
  
  function refresh() {
    
    _autoRolloverCompleted = false;
    
    // Add loading state to refresh button
    const refreshBtn = document.getElementById('refreshNetWorth');
    if (refreshBtn) {
      refreshBtn.classList.add('loading');
    }
    
    if (window.CacheManager && typeof CacheManager.invalidate === 'function') {
      CacheManager.invalidate('networth_with_timestamp');
    }
    
    showLoadingState();
    fetchFreshNetWorthData();
  }
  
  function setupAutocomplete(inputElement, suggestions, container) {
    inputElement.addEventListener('input', function() {
      const query = this.value.trim().toLowerCase();
      
      container.innerHTML = '';
      
      if (query.length < 1) {
        container.style.display = 'none';
        return;
      }
      
      const matches = suggestions.filter(suggestion => 
        suggestion.toLowerCase().includes(query)
      );
      
      if (matches.length === 0) {
        container.style.display = 'none';
        return;
      }
      
      matches.forEach(suggestion => {
        const suggestionItem = document.createElement('div');
        suggestionItem.className = 'nw-suggestion-item';
        
        const regex = new RegExp(`(${query})`, 'i');
        const highlighted = suggestion.replace(regex, '<strong>$1</strong>');
        
        suggestionItem.innerHTML = highlighted;
        
        suggestionItem.addEventListener('click', () => {
          inputElement.value = suggestion;
          container.style.display = 'none';
        });
        
        container.appendChild(suggestionItem);
      });
      
      container.style.display = 'block';
    });
    
    inputElement.addEventListener('keydown', function(e) {
      const items = container.querySelectorAll('.nw-suggestion-item');
      const activeItem = container.querySelector('.nw-suggestion-item.active');
      
      if (items.length === 0) return;
      
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        
        if (!activeItem) {
          items[0].classList.add('active');
        } else {
          activeItem.classList.remove('active');
          const nextItem = activeItem.nextElementSibling || items[0];
          nextItem.classList.add('active');
        }
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        
        if (!activeItem) {
          items[items.length - 1].classList.add('active');
        } else {
          activeItem.classList.remove('active');
          const prevItem = activeItem.previousElementSibling || items[items.length - 1];
          prevItem.classList.add('active');
        }
      } else if (e.key === 'Enter' && activeItem) {
        e.preventDefault();
        inputElement.value = activeItem.textContent;
        container.style.display = 'none';
      } else if (e.key === 'Escape') {
        container.style.display = 'none';
      }
    });
    
    document.addEventListener('click', function(e) {
      if (container && !container.contains(e.target) && e.target !== inputElement) {
        container.style.display = 'none';
      }
    });
  }
  
  function setMonthYear(month, year) {
    
    _currentMonth = parseInt(month);
    _currentYear = parseInt(year);
    
    calculateSummary();
    renderNetWorthView();
  }
  
  /**
   * Update last refresh time display for NetWorth view
   */
  function updateLastRefreshTime() {
    const now = new Date();
    const timeStr = now.toLocaleTimeString('en-US', { 
      hour: 'numeric', 
      minute: '2-digit',
      hour12: true 
    });
    
    const refreshElement = document.getElementById('lastRefreshTimeNetWorth');
    if (refreshElement) {
      const updatedAtText = window.getTranslation ? window.getTranslation('updated_at', getLanguageFromSettings()) : 'Updated at';
      refreshElement.textContent = `${updatedAtText} ${timeStr}`;
    }
  }
  
  /**
   * Show month/year editor popup for NetWorth
   */
  function showMonthYearEditor(displayElementId) {
    const displayElement = document.getElementById(displayElementId);
    if (!displayElement) return;
    
    // Create modal
    const modal = document.createElement('div');
    modal.className = 'month-year-editor-modal';
    
    // Generate month options
    const months = [
      'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
      'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
    ];
    
    const monthOptions = months.map((month, index) => 
      `<option value="${index}" ${index === _currentMonth ? 'selected' : ''}>${month}</option>`
    ).join('');
    
    // Generate year options (current year ± 5 years)
    const currentYear = new Date().getFullYear();
    const yearOptions = [];
    for (let year = currentYear - 5; year <= currentYear + 5; year++) {
      yearOptions.push(`<option value="${year}" ${year === _currentYear ? 'selected' : ''}>${year}</option>`);
    }
    
    modal.innerHTML = `
      <div class="modal-backdrop"></div>
      <div class="modal-content">
        <h3 data-translate="go_to_month_year">Go to Month/Year</h3>
        <div class="editor-inputs">
          <div class="select-group">
            <label data-translate="month_label">Month</label>
            <select id="monthSelect" class="month-year-select">
              ${monthOptions}
            </select>
          </div>
          <div class="select-group">
            <label data-translate="year_label">Year</label>
            <select id="yearSelect" class="month-year-select">
              ${yearOptions.join('')}
            </select>
          </div>
        </div>
        <div class="editor-buttons">
          <button class="btn editor-cancel" data-translate="cancel_button">Cancel</button>
          <button class="btn editor-save" data-translate="go_button">Go</button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Apply translations to the dynamically created modal
    if (window.SimBudget && SimBudget.applyTranslations) {
      SimBudget.applyTranslations();
    }
    
    // Focus on month select (but not on mobile to prevent auto-opening dropdown)
    const monthSelect = modal.querySelector('#monthSelect');
    if (!window.matchMedia('(max-width: 768px)').matches) {
      monthSelect.focus();
    }
    
    // Event listeners
    modal.querySelector('.editor-cancel').addEventListener('click', () => {
      modal.remove();
    });
    
    modal.querySelector('.modal-backdrop').addEventListener('click', () => {
      modal.remove();
    });
    
    modal.querySelector('.editor-save').addEventListener('click', () => {
      const month = parseInt(monthSelect.value); // Already 0-based
      const year = parseInt(modal.querySelector('#yearSelect').value);
      
      setMonthYear(month, year);
      modal.remove();
    });
    
    // Enter key to save
    modal.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        modal.querySelector('.editor-save').click();
      } else if (e.key === 'Escape') {
        modal.remove();
      }
    });
    
    // Show modal
    setTimeout(() => modal.classList.add('visible'), 10);
  }
  
  // Public API
  return {
    init: init,
    refresh: refresh,
    setMonthYear: setMonthYear,
    navigateMonth: navigateMonth,

     // ADD THIS NEW METHOD:
  updateDataSilently: function(entries) {
    if (!entries || !Array.isArray(entries)) return;
    
    _netWorthData.entries = entries;
    
    // Process the new data
    assignColorsToAssetTypes();
    checkAutoRollover();
    calculateSummary();
    renderNetWorthView();

    hideLoadingIndicator();
  },
    
    // For debugging
    getNetWorthData: () => _netWorthData,
    getCurrentMonth: () => _currentMonth,
    getCurrentYear: () => _currentYear,
    isAutoRolloverCompleted: () => _autoRolloverCompleted,
    resetAutoRollover: () => { _autoRolloverCompleted = false;  },
    getAssetTypeColors: () => ASSET_TYPE_COLORS,
    showLoadingState: showLoadingState,
    hideLoadingIndicator: hideLoadingIndicator
    
  };
})();

// Expose globally
window.NetWorthManager = NetWorthManager;
</script>

<style>
/* ==============================================================
    NET WORTH MANAGER - PROFESSIONAL STYLES WITH CHART AND ASSET ALLOCATION
    UPDATED: Narrower desktop layout, remove toggle, calculated changes
   ==============================================================
*/

/* ======== STICKY HEADER & SUMMARY ======== */
#netWorthView {
  --networth-header-height: 72px;
}

#netWorthView .view-header {
  background: var(--background, #f5f5f7);
}

#netWorthView .view-header .month-banner {
  box-shadow: none !important;
}

#netWorthView .networth-banner-summary {
  display: none;
}

#netWorthView .networth-banner-summary.hidden {
  display: none;
}

#netWorthView .networth-banner-value {
  font-size: 16px;
  font-weight: 700;
}

#netWorthView .month-selector {
  order: 0;
  margin: 0;
}

#netWorthView .refresh-info {
  order: 2;
  margin: 0;
}

body.dark-mode #netWorthView .view-header {
  background: var(--dark-background, #1c1c1e);
  box-shadow: 0 12px 32px rgba(0, 0, 0, 0.45);
}

body.dark-mode #netWorthView .networth-banner-summary {
  background: rgba(28, 28, 30, 0.6);
  color: rgba(255, 255, 255, 0.88);
}

@media (max-width: 768px) {
  #netWorthView {
    --networth-header-height: 88px;
  }

  #netWorthView .networth-banner-summary {
    font-size: 12px;
    gap: 4px;
  }

  #netWorthView .month-selector {
    gap: 4px;
  }

  #netWorthView .month-year-display {
    min-width: 90px;
    font-size: 15px;
    padding: 2px 6px;
  }

  .nw-chart-container {
    order: -9999 !important;
    margin: 16px 16px 24px 16px;
  }
}


/* ======== MAIN CONTAINER PADDING ======== */
.nw-loading,
.nw-error,
.nw-chart-container,
.nw-categories-grid,
.nw-future-message {
  margin-left: 16px;
  margin-right: 16px;
}

/* ======== LOADING & ERROR STATES ======== */
.nw-loading,
.nw-error {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 60px 20px;
  text-align: center;
  background-color: #ffffff;
  border-radius: 0px;
  border-top: 1px solid rgba(0, 0, 0, 0.5);
  border-left: 1px solid rgba(0, 0, 0, 0.5);
  border-right: 4px solid #334a60;
  border-bottom: 4px solid #334a60;
  margin: 20px 0;
}

.nw-loading-text {
  margin-top: 16px;
  color: var(--text-secondary, #666);
  font-size: 14px;
}

.nw-error-icon {
  margin-bottom: 16px;
  color: var(--error, #f44336);
}

.nw-error-icon i {
  font-size: 48px;
}

.nw-error h3 {
  margin: 0 0 8px;
  font-size: 18px;
  font-weight: 500;
  color: var(--text-primary, #333);
  font-family: 'Lato', sans-serif;
}

.nw-error p {
  margin: 0 0 24px;
  color: var(--text-secondary, #666);
  font-size: 14px;
}

/* ======== MESSAGES ======== */
.nw-message {
  padding: 12px 16px;
  border-radius: 0px;
  margin-bottom: 16px;
  font-weight: 500;
  font-size: 13px;
  border-top: 1px solid rgba(0, 0, 0, 0.5);
  border-left: 1px solid rgba(0, 0, 0, 0.5);
  border-right: 4px solid #334a60;
  border-bottom: 4px solid #334a60;
}

.nw-success-message {
  background-color: #e8f5e9;
  color: #2e7d32;
}

.nw-error-message {
  background-color: #ffebee;
  color: #d32f2f;
}

.nw-info-message {
  background-color: #e3f2fd;
  color: #1976d2;
}

/* ======== CHART CONTAINER - COLLAPSIBLE WITH SUMMARY HEADER ======== */
.nw-chart-container {
  background-color: #ffffff;
  border-radius: 8px;
  border: 1px solid rgba(0, 0, 0, 0.08);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.06);
  overflow: visible;
  max-width: 70%;
  margin: 16px auto 20px auto;
  padding: 0;
  display: flex !important;
  flex-direction: column;
  transition: box-shadow 0.3s ease;
}

@media (min-width: 1024px) {
  .nw-chart-container {
    margin-left: auto;
    margin-right: auto;
  }
}

/* ======== CHART HEADER WITH GRADIENT ======== */
.nw-chart-header {
  display: flex !important;
  justify-content: center;
  align-items: center;
  padding: 16px 20px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
  border-bottom: none;
  border-radius: 8px 8px 0 0;
  position: relative;
  min-height: 56px;
  box-shadow: 0 4px 12px rgba(102, 126, 234, 0.15);
  width: 100%;
  box-sizing: border-box;
}

/* ======== CHART SUMMARY INFO ======== */
.nw-chart-summary {
  display: flex;
  justify-content: center;
  align-items: center;
  flex-wrap: wrap;
  gap: 20px;
  color: white;
  font-size: 15px;
  font-weight: 600;
  text-align: center;
  line-height: 1.4;
  font-family: 'Lato', sans-serif;
}

.nw-summary-item {
  display: flex;
  align-items: center;
  gap: 4px;
}

.nw-summary-total {
  font-size: 17px;
  font-weight: 700;
}

.nw-summary-separator {
  opacity: 0.6;
}

.nw-summary-line {
  display: flex;
  align-items: center;
  gap: 8px;
}

.nw-chart-summary .nw-change-positive {
  color: #90EE90;
}

.nw-chart-summary .nw-change-negative {
  color: #FFB6C1;
}

/* ======== CHART TOGGLE BUTTON ======== */
.nw-chart-toggle {
  position: absolute;
  top: 50%;
  right: 16px;
  transform: translateY(-50%);
  background: none;
  border: none;
  color: white;
  cursor: pointer;
  padding: 8px 12px;
  font-size: 14px;
}

.nw-chart-toggle-icon {
  display: inline-block;
}

/* ======== CHART CONTENT (COLLAPSIBLE) ======== */
.nw-chart-content {
  display: block;
  background-color: #ffffff;
}

/* ======== CHART CONTROLS BAR ======== */
.nw-chart-controls-bar {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 16px 20px;
  background-color: #f8f9fa;
  border-top: 1px solid #eee;
}

/* ======== CHART CONTROLS LAYOUT ======== */
.nw-chart-controls {
  display: flex;
  align-items: center;
  gap: 16px;
  width: 100%;
  justify-content: center;
  flex-wrap: wrap;
}

/* ======== MODE BUTTONS ======== */
.nw-mode-buttons {
  display: flex;
  gap: 8px;
  align-items: center;
}

.nw-mode-btn {
  background: none;
  border: 2px solid #e0e0e0;
  color: #666;
  cursor: pointer;
  font-size: 13px;
  font-weight: 600;
  padding: 8px 12px;
  border-radius: 6px;
  transition: all 0.2s ease;
  font-family: 'Lato', sans-serif;
  display: flex;
  align-items: center;
  gap: 6px;
  white-space: nowrap;
  min-width: 44px;
  justify-content: center;
}

.nw-mode-btn i {
  font-size: 18px;
}

.nw-mode-btn:hover {
  border-color: #2c3e50;
  color: #2c3e50;
  background-color: rgba(44, 62, 80, 0.04);
}

.nw-mode-btn.active {
  background-color: #2c3e50;
  border-color: #2c3e50;
  color: white;
}

/* ======== TIMESPAN CONTROLS ======== */
.nw-timespan-controls {
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
}

.nw-timespan-controls.hidden {
  display: none;
}

/* Performance year controls should not wrap on mobile */
#performanceYearControls {
  flex-wrap: nowrap;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
}

/* Hide scrollbar but keep functionality */
#performanceYearControls::-webkit-scrollbar {
  display: none;
}

#performanceYearControls {
  -ms-overflow-style: none;
  scrollbar-width: none;
}

.nw-timespan-btn {
  background: none;
  border: 2px solid #e0e0e0;
  color: #666;
  cursor: pointer;
  font-size: 12px;
  font-weight: 600;
  padding: 6px 12px;
  border-radius: 4px;
  transition: all 0.2s ease;
  font-family: 'Lato', sans-serif;
}

.nw-timespan-btn:hover {
  border-color: #2c3e50;
  color: #2c3e50;
}

.nw-timespan-btn.active {
  background-color: #2c3e50;
  border-color: #2c3e50;
  color: white;
}

.nw-more-years-btn {
  padding: 6px 8px;
  min-width: 32px;
}

.nw-more-years-btn.expanded {
  background-color: #e0e0e0;
}

.nw-chart-wrapper {
  padding: 20px;
  height: 400px;
  position: relative;
  min-height: 400px;
  width: 100%;
  overflow: hidden;
}

#netWorthChart {
  width: 100% !important;
  height: 100% !important;
  max-height: 400px;
}

/* Mobile responsive for chart and summary header */
@media (max-width: 768px) {
  .nw-chart-wrapper {
    padding: 15px;
    height: 400px;
    min-height: 400px;
    overflow: hidden;
    clip-path: inset(0);
  }

  .nw-chart-container {
    min-height: auto;
    overflow: hidden !important;
  }

  .nw-chart-container.chart-collapsed {
    min-height: auto;
  }

  .nw-chart-header {
    display: flex !important;
    padding: 14px 50px 14px 16px;
    min-height: 50px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
  }

  .nw-chart-summary {
    font-size: 13px;
    gap: 8px;
    flex-direction: column;
    color: white !important;
  }

  .nw-chart-summary .nw-summary-separator {
    display: none;
  }

  .nw-summary-line {
    gap: 6px;
  }

  .nw-summary-total {
    font-size: 15px;
  }

  .nw-chart-toggle {
    right: 10px;
    padding: 6px 10px;
    color: white !important;
  }

  .nw-chart-controls-bar {
    padding: 12px 16px;
  }
}

/* Desktop - limit width */
@media (min-width: 1024px) {
  .nw-chart-container {
    max-width: 70%;
  }
}


/* ======== CATEGORIES GRID - UPDATED FOR NARROWER LAYOUT ======== */
/* Legacy nw-total-header kept for backwards compatibility */
.nw-total-header {
  display: none; /* Now integrated into chart header */
}

.nw-categories-grid {
  display: grid;
  grid-template-columns: 1fr;
  gap: 16px;
  margin: 8px auto 0 auto;
  max-width: 70%;
}

/* Desktop: 2-column layout */
@media (min-width: 1024px) {
  .nw-categories-grid {
    grid-template-columns: 1fr 1fr;
    gap: 24px;
  }
}

@media (max-width: 1023px) and (min-width: 768px) {
  .nw-categories-grid {
    grid-template-columns: 1fr 1fr;
    gap: 20px;
  }
}

/* ======== CATEGORY SECTIONS ======== */
.nw-section {
  background-color: #ffffff;
  border-radius: 8px;
  border-top: 1px solid rgb(51 74 96 / 20%);
  border-left: 2px solid rgb(51 74 96 / 20%);
  border-right: 2px solid rgb(51 74 96 / 20%);
  border-bottom: 4px solid rgb(51 74 96 / 20%);
  overflow: visible;
  padding-bottom: 15px;
  min-height: 300px;
}

.nw-section-debt .nw-section-title {
  color: #e74c3c;
}

.nw-section-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 20px;
  background-color: #f8f9fa;
  border-radius: 8px;
}

/* ======== ENHANCED SECTION TITLE CONTAINER ======== */
.nw-section-title-container {
  display: flex;
  align-items: center;
  gap: 12px;
  flex-wrap: wrap;
}

.nw-section-title {
  margin: 0;
  font-size: 17px;
  font-weight: 600;
  font-family: 'Lato', sans-serif;
  color: #1565c0;
  letter-spacing: -0.02em;
}

.nw-totals-display {
  display: flex;
  align-items: center;
  gap: 8px;
}

/* ======== PROFESSIONAL BADGE STYLING ======== */
.nw-total-container {
  display: flex;
  align-items: center;
}

.nw-total-badge-asset {
  background-color: #e3f2fd;
  color: #1565c0;
  padding: 4px 10px;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 600;
  font-family: 'Lato', sans-serif;
  display: flex;
  align-items: center;
  gap: 6px;
}

.nw-total-badge-debt {
  background-color: #ffebee;
  color: #c62828;
  padding: 4px 10px;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 600;
  font-family: 'Lato', sans-serif;
  display: flex;
  align-items: center;
  gap: 6px;
}

.nw-badge-total {
  font-size: 13px;
  font-weight: 700;
}

.nw-badge-change {
  font-size: 11px;
  font-weight: 500;
  opacity: 0.8;
}

/* ======== CHANGE INDICATORS ======== */
.nw-change {
  font-size: 12px;
  font-weight: 500;
}

.nw-change-positive {
  color: #2e7d32;
}

.nw-change-negative {
  color: #d32f2f;
}

/* ======== HEADER CONTROLS - NEW ======== */
.nw-header-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.nw-add-btn,
.nw-remove-toggle {
  background: none;
  border: none;
  color: #2c3e50;
  cursor: pointer;
  font-size: 13px;
  display: flex;
  align-items: center;
  padding: 6px 12px;
  border-radius: 4px;
  transition: background-color 0.2s ease;
  font-weight: 500;
}

.nw-add-btn:hover {
  background-color: rgba(44, 62, 80, 0.08);
}

.nw-remove-toggle {
  color: #666;
}

.nw-remove-toggle:hover {
  background-color: rgba(244, 67, 54, 0.08);
  color: #f44336;
}

.nw-remove-toggle[data-active="true"] {
  background-color: rgba(244, 67, 54, 0.12);
  color: #f44336;
}

.nw-add-btn i,
.nw-remove-toggle i {
  font-size: 18px;
  margin-right: 6px;
}

.nw-empty-state {
  padding: 40px 20px;
  text-align: center;
  color: var(--text-secondary, #666);
  font-size: 14px;
  font-style: italic;
}

/* ======== TABLES - UPDATED FOR 5 COLUMNS ======== */
.nw-table-container {
  overflow: visible;
  height: auto;
  max-height: none;
  width: 100%;
}

.nw-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 13px;
  table-layout: auto;
}

.nw-table th,
.nw-table td {
  padding: 4px 4px 4px 15px;
  text-align: left;
  border-bottom: 1px solid #f0f0f0;
  word-wrap: break-word;
  overflow-wrap: break-word;
}

.nw-table th {
  font-weight: 600;
  color: #64748b;
  font-size: 12px;
  background-color: #fafafa;
  font-family: 'Lato', sans-serif;
  text-transform: capitalize;
}

.nw-table th.nw-sortable {
  cursor: pointer;
  user-select: none;
  transition: background-color 0.2s ease;
}

.nw-table th.nw-sortable:hover {
  background-color: #f0f0f0;
}

.nw-sort-indicator {
  font-size: 10px;
  margin-left: 4px;
  color: #1976d2;
}

.nw-type-cell {
  width: 20%;
  font-weight: 500;
  color: #666;
}

.nw-name-cell {
  width: 25%;
  font-weight: 600;
  color: #2c3e50;
}

.nw-value-cell {
  width: 20%;
  text-align: right;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
  color: #2c3e50;
}

.nw-change-cell {
  width: 20%;
  text-align: right;
  font-family: 'Lato', sans-serif;
  font-weight: 600;
}

.nw-actions-cell {
  width: 15%;
  text-align: right;
}

/* ======== CHANGE DISPLAY STYLES - NEW ======== */
.nw-positive-change {
  color: #4caf50;
}

.nw-negative-change {
  color: #f44336;
}

.nw-new-entry {
  color: #2196f3;
  font-style: italic;
  font-size: 12px;
}

.nw-no-change {
  color: #999;
  font-size: 12px;
}

/* ======== ZERO VALUE INDICATORS ======== */
.nw-table tr.nw-zero-value {
  opacity: 0.7;
}

.nw-table tr.nw-zero-value .nw-value-cell {
  color: #999;
  font-style: italic;
}

/* ======== INTERACTIVE ELEMENTS ======== */
.nw-editable {
  cursor: pointer;
  border-radius: 4px;
  padding: 6px 8px;
  margin: -6px -8px;
  transition: background-color 0.2s ease;
  min-width: 60px;
  display: inline-block;
}

.nw-editable:hover {
  background-color: rgba(0, 0, 0, 0.04);
}

.nw-edit-wrapper {
  display: flex;
  align-items: center;
  background-color: white;
  border: 2px solid #2c3e50;
  border-radius: 4px;
  padding: 4px 8px;
}

.nw-edit-currency {
  margin-right: 4px;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
  color: #666;
}

/* Inline currency for contenteditable amount fields */
.nw-edit-currency-inline {
  font-family: 'Lato', sans-serif;
  font-weight: 700;
  color: #666;
  user-select: none;
  pointer-events: none;
}

.nw-editable.nw-editing {
  background-color: rgba(0, 0, 0, 0.04);
  box-shadow: 0 0 0 2px rgba(25, 118, 210, 0.3);
  outline: none;
  min-width: 60px;
}

body.dark-mode .nw-edit-currency-inline {
  color: rgba(255, 255, 255, 0.6);
}

body.dark-mode .nw-editable.nw-editing {
  background-color: rgba(255, 255, 255, 0.1);
  box-shadow: 0 0 0 2px rgba(74, 163, 223, 0.4);
}

/* Saving indicator - spinner */
.nw-editable.nw-saving {
  position: relative;
}

.nw-editable.nw-saving::after {
  content: '';
  position: absolute;
  right: 4px;
  top: 50%;
  transform: translateY(-50%);
  width: 12px;
  height: 12px;
  border: 2px solid #1976d2;
  border-top-color: transparent;
  border-radius: 50%;
  animation: nw-spin 1s linear infinite;
}

@keyframes nw-spin {
  0% { transform: translateY(-50%) rotate(0deg); }
  100% { transform: translateY(-50%) rotate(360deg); }
}

/* Saved indicator - brief green flash */
.nw-editable.nw-saved {
  background-color: rgba(76, 175, 80, 0.15) !important;
  transition: background-color 0.3s ease;
}

/* Error indicator */
.nw-editable.nw-error {
  background-color: rgba(244, 67, 54, 0.15) !important;
  transition: background-color 0.3s ease;
}

body.dark-mode .nw-editable.nw-saving::after {
  border-color: #4aa3df;
  border-top-color: transparent;
}

body.dark-mode .nw-editable.nw-saved {
  background-color: rgba(76, 175, 80, 0.25) !important;
}

body.dark-mode .nw-editable.nw-error {
  background-color: rgba(244, 67, 54, 0.25) !important;
}

.nw-edit-input {
  background: transparent;
  border: none;
  outline: none;
  width: 100%;
  text-align: right;
  font-size: 13px;
  font-family: 'Lato', sans-serif;
  font-weight: 700;
  color: #2c3e50;
}

/* Action buttons */
.nw-action-btn {
  background: none;
  border: none;
  cursor: pointer;
  color: #666;
  width: 28px;
  height: 28px;
  padding: 0;
  margin: 0 2px;
  border-radius: 4px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.nw-action-btn:hover {
  background-color: rgba(0, 0, 0, 0.06);
  transform: translateY(-1px);
}

.nw-action-btn i {
  font-size: 16px;
}

.nw-delete-btn {
  color: var(--error, #f44336);
}

.nw-delete-btn:hover {
  background-color: rgba(244, 67, 54, 0.08);
}

.nw-delete-btn.nw-hidden {
  display: none;
}

.nw-notes-btn:hover {
  background-color: rgba(102, 102, 102, 0.08);
}

/* Save indicators */
.nw-saving {
  position: relative;
  opacity: 0.7;
}

.nw-saving::after {
  content: '';
  position: absolute;
  top: 50%;
  right: 4px;
  transform: translateY(-50%);
  width: 8px;
  height: 8px;
  border: 2px solid #2c3e50;
  border-top-color: transparent;
  border-radius: 50%;
  animation: nw-spin 1s linear infinite;
}

.nw-saved {
  background-color: rgba(76, 175, 80, 0.1) !important;
  transition: background-color 0.5s ease;
}

@keyframes nw-spin {
  0% { transform: translateY(-50%) rotate(0deg); }
  100% { transform: translateY(-50%) rotate(360deg); }
}

/* ======== ENHANCED MODALS - UPDATED WITH 2-COLUMN LAYOUT ======== */
.nw-modal-backdrop {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.6);
  z-index: 10001;
  backdrop-filter: blur(2px);
}

.nw-modal {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: white;
  border-radius: 12px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
  z-index: 10002;
  width: auto;
  max-width: 90vw;
  max-height: 90vh;
  overflow-y: auto;
  animation: nw-modal-appear 0.2s ease;
}

@keyframes nw-modal-appear {
  from {
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.9) translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1) translateY(0);
  }
}

/* Enhanced modal for add asset form - UPDATED */
.nw-enhanced-modal {
  width: 550px;
  max-width: 90vw;
}

.nw-notes-modal {
  max-width: 400px;
}

.nw-modal-header {
  padding: 16px 20px;
  border-bottom: 1px solid #eee;
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
  border-radius: 12px 12px 0 0;
}

.nw-modal-header h3 {
  margin: 0;
  font-size: 18px;
  font-weight: 700;
  font-family: 'Lato', sans-serif;
  color: #2c3e50;
}

.nw-modal-close {
  background: none;
  border: none;
  font-size: 24px;
  cursor: pointer;
  color: #999;
  padding: 0;
  line-height: 1;
  transition: color 0.15s;
}

.nw-modal-close:hover {
  color: #333;
}

.nw-modal-body {
  padding: 20px 24px;
}

.nw-modal-footer {
  display: flex;
  justify-content: center;
  gap: 12px;
  padding: 20px 24px;
  background: #f8f9fa;
  border-top: 1px solid #eee;
  border-radius: 0 0 12px 12px;
}

/* ======== COMPACT SINGLE-COLUMN MODAL ======== */
.nw-compact-modal {
  width: 380px;
  max-width: 90vw;
}

.nw-single-col-form {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.nw-form-field {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.nw-form-field label {
  font-size: 13px;
  font-weight: 600;
  color: #2c3e50;
  font-family: 'Lato', sans-serif;
}

/* ======== NEW POPUP GRID STYLES (matching recurring.js.html) ======== */
.nw-popup-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
}

.nw-grid-item {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.nw-grid-item label {
  font-size: 13px;
  font-weight: 600;
  color: #2c3e50;
  font-family: 'Lato', sans-serif;
}

.nw-input {
  width: 100%;
  padding: 10px 12px;
  border: 1px solid #ddd;
  border-radius: 6px;
  font-size: 14px;
  font-family: 'Lato', sans-serif;
  box-sizing: border-box;
  transition: border-color 0.2s ease, box-shadow 0.2s ease;
}

.nw-input:focus {
  outline: none;
  border-color: #4a90a4;
  box-shadow: 0 0 0 3px rgba(74, 144, 164, 0.1);
}

.nw-input-amount {
  position: relative;
  display: flex;
  align-items: center;
}

.nw-currency {
  position: absolute;
  left: 12px;
  color: #666;
  font-size: 14px;
  pointer-events: none;
  z-index: 1;
}

.nw-input-amount .nw-input {
  padding-left: 28px;
}

.nw-autocomplete-wrapper {
  position: relative;
}

.nw-notes-item {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.nw-add-note-btn {
  width: 100%;
  padding: 10px 12px;
  border: 1px dashed #ccc;
  background: #fafafa;
  color: #666;
  border-radius: 6px;
  font-size: 13px;
  cursor: pointer;
  font-family: 'Lato', sans-serif;
  transition: all 0.2s ease;
}

.nw-add-note-btn:hover {
  border-color: #4a90a4;
  color: #4a90a4;
  background: #f5f9fa;
}

.nw-notes-area {
  margin-top: 4px;
}

.nw-textarea {
  min-height: 80px;
  resize: vertical;
}

/* Button styles for popup footer (matching recurring.js.html) */
.nw-btn-cancel,
.nw-btn-save,
.nw-btn-delete {
  padding: 10px 20px;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
}

.nw-btn-cancel {
  background: white;
  border: 1px solid #ddd;
  color: #666;
}

.nw-btn-cancel:hover {
  background: #f5f5f5;
}

.nw-btn-save {
  background: #2c3e50;
  border: 1px solid #2c3e50;
  color: white;
}

.nw-btn-save:hover:not(:disabled) {
  background: #1a252f;
}

.nw-btn-save:disabled {
  background: #ccc;
  border-color: #ccc;
  cursor: not-allowed;
}

.nw-btn-delete {
  background: white;
  border: 1px solid #f44336;
  color: #f44336;
}

.nw-btn-delete:hover {
  background: #f44336;
  color: white;
}

/* Edit modal footer - centered like recurring */
.nw-edit-footer {
  justify-content: center;
}

/* Dark mode for new popup styles */
body.dark-mode .nw-grid-item label {
  color: rgba(255,255,255,0.9);
}

body.dark-mode .nw-input {
  background: rgba(255,255,255,0.08);
  border-color: rgba(255,255,255,0.15);
  color: #fff;
}

body.dark-mode .nw-input:focus {
  border-color: #4a90a4;
  box-shadow: 0 0 0 3px rgba(74, 144, 164, 0.2);
}

body.dark-mode .nw-input::placeholder {
  color: rgba(255,255,255,0.4);
}

body.dark-mode .nw-form-field label {
  color: rgba(255,255,255,0.9);
}

body.dark-mode .nw-currency {
  color: rgba(255,255,255,0.6);
}

body.dark-mode .nw-add-note-btn {
  background: rgba(255,255,255,0.05);
  border-color: rgba(255,255,255,0.2);
  color: rgba(255,255,255,0.6);
}

body.dark-mode .nw-add-note-btn:hover {
  border-color: #6ab0c5;
  color: #6ab0c5;
  background: rgba(106, 176, 197, 0.1);
}

body.dark-mode .nw-btn-cancel {
  background: #2a2a2a;
  border-color: rgba(255,255,255,0.15);
  color: rgba(255,255,255,0.8);
}

body.dark-mode .nw-btn-cancel:hover {
  background: #333;
}

body.dark-mode .nw-btn-save {
  background: #4a90a4;
  border-color: #4a90a4;
}

body.dark-mode .nw-btn-save:hover:not(:disabled) {
  background: #5aa0b4;
}

body.dark-mode .nw-btn-delete {
  border-color: #e74c3c;
  color: #e74c3c;
  background: transparent;
}

body.dark-mode .nw-btn-delete:hover {
  background: #e74c3c;
  color: white;
}

/* ======== ENHANCED FORM LAYOUTS - 2 COLUMN DESIGN ======== */
.nw-enhanced-form {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.nw-form-group {
  display: grid;
  grid-template-columns: 70px 1fr;
  align-items: center;
  gap: 16px;
}

.nw-form-label {
  text-align: right;
}

.nw-form-label label {
  font-weight: 600;
  font-size: 14px;
  color: #2c3e50;
  font-family: 'Lato', sans-serif;
}

.nw-required {
  color: #f44336;
  font-size: 16px;
  font-weight: normal;
}

.nw-form-input {
  position: relative;
}

.nw-input {
  padding: 12px 14px;
  font-size: 14px;
  background-color: white;
  border: 2px solid #e0e0e0;
  border-radius: 6px;
  transition: border-color 0.2s ease;
  font-family: inherit;
  width: 100%;
}

.nw-input:focus {
  outline: none;
  border-color: #2c3e50;
}

.nw-textarea {
  resize: vertical;
  min-height: 80px;
  font-family: inherit;
}

.nw-amount-wrapper {
  position: relative;
  width: 100%;
}



.nw-amount {
  padding-left: 32px;
  font-family: 'Lato', sans-serif;
  font-weight: 600;
  text-align: right;
  width: 100%;
}

/* ======== BUTTONS ======== */
.nw-btn {
  padding: 10px 20px;
  border-radius: 6px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  border: none;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  text-decoration: none;
  font-family: 'Lato', sans-serif;
}

.nw-btn i {
  margin-right: 8px;
  font-size: 16px;
}

.nw-btn-primary {
  background-color: #2c3e50;
  color: white;
}

.nw-btn-primary:hover {
  background-color: #1e2b37;
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(44, 62, 80, 0.3);
}

.nw-btn-primary:disabled {
  background-color: #a9d4a9;
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
  color: #666;
}

.nw-btn-secondary {
  background-color: transparent;
  border: 2px solid #2c3e50;
  color: #2c3e50;
}

.nw-btn-secondary:hover {
  background-color: #2c3e50;
  color: white;
  transform: translateY(-1px);
}

/* ======== POPUP BUTTON STYLES (matching income.js.html) ======== */
.nw-add-btn {
  padding: 10px 20px;
  border: none;
  border-radius: 0px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  min-width: 80px;
}

.nw-add-cancel-btn {
  background-color: #f5f5f5;
  color: #666;
  border: 1px solid #ddd;
}

.nw-add-cancel-btn:hover {
  background-color: #e8e8e8;
  color: #2c3e50;
}

.nw-add-save-btn {
  background-color: #2c3e50;
  color: white;
}

.nw-add-save-btn:hover {
  background-color: #1984c5;
}

.nw-add-save-btn:focus, .nw-add-cancel-btn:focus {
  outline: 2px solid #2c3e50;
  outline-offset: 2px;
}

.nw-add-delete-btn {
  margin-right: auto;
  background-color: #f44336;
  color: white;
}

.nw-add-delete-btn:hover {
  background-color: #d32f2f;
}

/* ======== FUTURE MONTH SCREEN ======== */
.nw-future-message {
  text-align: center;
  padding: 60px 30px;
  background-color: white;
  border-radius: 0px;
  border-top: 1px solid rgba(0, 0, 0, 0.5);
  border-left: 1px solid rgba(0, 0, 0, 0.5);
  border-right: 4px solid #334a60;
  border-bottom: 4px solid #334a60;
  margin: 20px 0;
}

.nw-future-icon {
  margin-bottom: 20px;
  color: #666;
}

.nw-future-icon i {
  font-size: 64px;
  color: #bbb;
}

.nw-future-message h3 {
  margin: 0 0 12px;
  font-size: 20px;
  font-weight: 600;
  color: #2c3e50;
  font-family: 'Lato', sans-serif;
}

.nw-future-message p {
  margin: 0 0 30px;
  color: #666;
  font-size: 16px;
  line-height: 1.5;
}

/* ======== AUTOCOMPLETE ======== */
.nw-autocomplete-container {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  max-height: 200px;
  overflow-y: auto;
  background: white;
  border: 2px solid #e0e0e0;
  border-top: none;
  border-radius: 0 0 6px 6px;
  box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  z-index: 1002;
}

.nw-suggestion-item {
  padding: 10px 14px;
  cursor: pointer;
  font-size: 14px;
  transition: background-color 0.2s;
}

.nw-suggestion-item:hover,
.nw-suggestion-item.active {
  background-color: #f5f5f5;
}

.nw-suggestion-item strong {
  font-weight: bold;
  color: #2c3e50;
}

/* ======== RESPONSIVE DESIGN ======== */
@media (max-width: 768px) {
  /* Chart controls responsive */
  .nw-chart-controls {
    flex-direction: row;
    flex-wrap: wrap;
    gap: 8px;
    justify-content: center;
  }
  
   
  .nw-timespan-btn.nw-all-btn,
  .nw-timespan-btn[data-timespan="5yr"] {
    display: none !important;
  }



  .nw-mode-btn {
    width: auto;
    justify-content: center;
    flex: 0 0 auto;
  }
  
  .nw-timespan-controls {
    width: auto;
    flex: 1 1 auto;
  }
  
  .nw-timespan-controls.hidden {
    display: none;
  }
  
  /* Mobile responsive for enhanced section titles */
  .nw-section-header {
    position: relative;
    padding: 12px 16px;
    padding-right: 50px;
  }

  .nw-section-title-container {
    flex-direction: row;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
  }

  .nw-section-title {
    font-size: 15px;
  }

  .nw-totals-display {
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .nw-header-controls {
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
  }
  
  .nw-total-badge-asset,
  .nw-total-badge-debt {
    font-size: 12px;
    padding: 3px 8px;
    gap: 4px;
  }
  
  .nw-badge-total {
    font-size: 12px;
  }
  
  .nw-badge-change {
    font-size: 10px;
  }
  
  .nw-change {
    font-size: 11px;
  }

  /* Chart controls responsive - these apply to the controls bar, not the summary header */
  .nw-chart-controls-bar {
    padding: 12px;
  }

  .nw-timespan-controls {
    justify-content: center;
    flex-wrap: wrap;
  }

  .nw-timespan-btn {
    flex: 1;
    min-width: 50px;
  }

  .nw-chart-wrapper {
    padding: 12px !important;
    height: 280px;
    min-height: 280px;
  }
  
  /* Table adjustments - now only hiding change column on mobile */
  .nw-table {
    font-size: 12px;
  }
  
  .nw-type-cell {
    width: 25%;
  }
  
  .nw-name-cell {
    width: 35%;
  }
  
  .nw-value-cell {
    width: 25%;
  }
  
  .nw-change-cell {
    display: none;
  }
  
  .nw-table th:nth-child(4) {
    display: none;
  }
  
  .nw-actions-cell {
    width: 15%;
    white-space: nowrap;
    padding-left: 0 !important;
    padding-right: 0 !important;
  }
  
  .nw-action-btn {
    width: 28px;
    height: 28px;
    margin: 0 1px;
    padding: 0;
  }
  
  .nw-action-btn i {
    font-size: 16px;
  }

  .nw-add-btn span,
  .nw-remove-toggle span {
    display: none;
  }
  
  .nw-add-btn i,
  .nw-remove-toggle i {
    margin-right: 0;
  }
  
  /* Mobile modal adjustments */
  .nw-modal {
    width: 95%;
    max-width: 95vw;
  }
  
  .nw-enhanced-modal {
    width: 95%;
  }
  
  /* Stack form on mobile */
  .nw-form-group {
    grid-template-columns: 1fr;
    gap: 8px;
  }
  
  .nw-form-label {
    text-align: left;
  }
  
  .nw-modal-body {
    padding: 16px;
  }
  
  .nw-modal-header,
  .nw-modal-footer {
    padding: 16px;
  }
}

@media (max-width: 480px) {
  .nw-mode-btn {
    font-size: 12px;
    padding: 6px 12px;
  }
  
  .nw-mode-btn i {
    font-size: 16px;
  }
}

@media (max-width: 600px) {
  .nw-enhanced-modal {
    width: 100%;
    /* height: 100%; */
    border-radius: 0;
    top: 50px;
    left: 10px;
    transform: none;
  }
}

/* ======== DARK MODE SUPPORT ======== */
body.dark-mode .nw-chart-container,
body.dark-mode .nw-section,
body.dark-mode .nw-modal,
body.dark-mode .nw-future-message,
body.dark-mode .nw-loading,
body.dark-mode .nw-error {
  background-color: var(--dark-surface, #1e1e1e);
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
}

body.dark-mode .nw-chart-container {
  box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45);
}

body.dark-mode .nw-section-header,
body.dark-mode .nw-modal-header {
  background: transparent;
  border-color: rgba(255, 255, 255, 0.18);
}

body.dark-mode .nw-modal-footer {
  background: #252525;
  border-top-color: rgba(255,255,255,0.1);
}

body.dark-mode .nw-section-title,
body.dark-mode .nw-modal-header h3 {
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
}

/* Dark mode chart header with purple gradient */
body.dark-mode .nw-chart-header {
  background: linear-gradient(135deg, #4c1d95 0%, #5b21b6 100%) !important;
  border-bottom: 1px solid rgba(139, 92, 246, 0.3);
  box-shadow: 0 4px 12px rgba(76, 29, 149, 0.3);
}

body.dark-mode .nw-chart-summary {
  color: white;
}

body.dark-mode .nw-chart-summary .nw-change-positive {
  color: #90EE90;
}

body.dark-mode .nw-chart-summary .nw-change-negative {
  color: #FFB6C1;
}

body.dark-mode .nw-chart-toggle {
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
}

body.dark-mode .nw-chart-controls-bar {
  background-color: var(--dark-surface, #2c2c2e);
  border-top-color: rgba(255, 255, 255, 0.08);
}

body.dark-mode .nw-chart-content {
  background-color: var(--dark-surface, #1e1e1e);
}

/* ======== DARK MODE BADGE STYLING ======== */
body.dark-mode .nw-total-badge-asset {
  background-color: rgba(33, 150, 243, 0.15);
  color: #64b5f6;
}

body.dark-mode .nw-total-badge-debt {
  background-color: rgba(244, 67, 54, 0.15);
  color: #ef5350;
}

body.dark-mode .nw-badge-total {
  color: inherit;
}

body.dark-mode .nw-badge-change {
  opacity: 0.7;
}

body.dark-mode .nw-change-positive {
  color: #66bb6a;
}

body.dark-mode .nw-change-negative {
  color: #ef5350;
}


body.dark-mode .nw-loading-text {
  color: white !important;
}

body.dark-mode .nw-mode-btn {
  border-color: rgba(255, 255, 255, 0.2);
  color: rgba(255, 255, 255, 0.6);
}

body.dark-mode .nw-mode-btn:hover {
  border-color: #DDA15E;
  color: #DDA15E;
  background-color: rgba(221, 161, 94, 0.08);
}

body.dark-mode .nw-mode-btn.active {
  background-color: #DDA15E;
  border-color: #DDA15E;
  color: #1e1e1e;
}

body.dark-mode .nw-timespan-btn {
  border-color: rgba(255, 255, 255, 0.2);
  color: rgba(255, 255, 255, 0.6);
}

body.dark-mode .nw-timespan-btn:hover {
  border-color: #DDA15E;
  color: #DDA15E;
}

body.dark-mode .nw-timespan-btn.active {
  background-color: #DDA15E;
  border-color: #DDA15E;
  color: #1e1e1e;
}

body.dark-mode .nw-more-years-btn.expanded {
  background-color: rgba(255, 255, 255, 0.1);
}

body.dark-mode .nw-table th {
  background-color: var(--dark-surface, #2c2c2e);
  color: rgba(255, 255, 255, 0.6);
}

body.dark-mode .nw-table th.nw-sortable:hover {
  background-color: rgba(255, 255, 255, 0.1);
}

body.dark-mode .nw-sort-indicator {
  color: #64b5f6;
}

body.dark-mode .nw-table td {
  border-color: rgba(255, 255, 255, 0.08);
}

body.dark-mode .nw-value-cell {
  color: #DDA15E;
}

body.dark-mode .nw-positive-change {
  color: #66bb6a;
}

body.dark-mode .nw-negative-change {
  color: #ef5350;
}

body.dark-mode .nw-new-entry {
  color: #42a5f5;
}

body.dark-mode .nw-name-cell {
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
}

body.dark-mode .nw-type-cell {
  color: rgba(255, 255, 255, 0.6);
}


body.dark-mode .nw-remove-toggle:hover {
  background-color: rgba(239, 83, 80, 0.08);
  color: #ef5350;
}

body.dark-mode .nw-remove-toggle[data-active="true"] {
  background-color: rgba(239, 83, 80, 0.12);
  color: #ef5350;
}

body.dark-mode .nw-input {
  background-color: var(--dark-surface, #2c2c2e);
  border-color: rgba(255, 255, 255, 0.2);
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
}

body.dark-mode .nw-input:focus {
  border-color: #DDA15E;
}

body.dark-mode .nw-edit-wrapper {
  background-color: var(--dark-surface, #2c2c2e);
  border-color: #DDA15E;
}

body.dark-mode .nw-edit-input {
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
}

body.dark-mode .nw-currency,
body.dark-mode .nw-edit-currency {
  color: rgba(255, 255, 255, 0.6);
}

body.dark-mode .nw-btn-primary {
  background-color: #abbccd;
  color: #1e1e1e;
}

body.dark-mode .nw-btn-primary:hover {
  background-color: #9bb0c4;
}

body.dark-mode .nw-btn-primary:disabled {
  background-color: #5a5a5a;
  color: rgba(255, 255, 255, 0.3);
}

body.dark-mode .nw-btn-secondary {
  border-color: #abbccd;
  color: #abbccd;
}

body.dark-mode .nw-btn-secondary:hover {
  background-color: #abbccd;
  color: #1e1e1e;
}

/* ======== POPUP BUTTON DARK MODE STYLES (matching income.js.html) ======== */
body.dark-mode .nw-add-cancel-btn {
  background-color: var(--dark-surface, #1e1e1e);
  color: var(--dark-text-secondary, rgba(255, 255, 255, 0.6));
  border-color: var(--dark-border, rgba(255, 255, 255, 0.12));
}

body.dark-mode .nw-add-cancel-btn:hover {
  background-color: rgba(255, 255, 255, 0.05);
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
}

body.dark-mode .nw-add-save-btn {
  background-color: #DDA15E;
  color: #000000 !important;
}

body.dark-mode .nw-add-save-btn:hover {
  background-color: #c9955a;
}

body.dark-mode .nw-add-save-btn:focus, body.dark-mode .nw-add-cancel-btn:focus {
  outline-color: #DDA15E;
}

body.dark-mode .nw-add-delete-btn {
  background-color: #ef5350;
  color: #f8f9fa !important
}

body.dark-mode .nw-add-delete-btn:hover {
  background-color: #f44336;
}

body.dark-mode .nw-editable:hover,
body.dark-mode .nw-action-btn:hover,
body.dark-mode .nw-add-btn,
body.dark-mode .nw-remove-toggle {
  color: #abbccd;
}

body.dark-mode .nw-add-btn:hover {
  background-color: rgba(171, 188, 205, 0.08);
}

body.dark-mode .nw-modal-close:hover {
  background-color: rgba(255, 255, 255, 0.08);
}

body.dark-mode .nw-saved {
  background-color: rgba(76, 175, 80, 0.08) !important;
}

body.dark-mode .nw-saving::after {
  border-color: #DDA15E;
  border-top-color: transparent;
}

body.dark-mode .nw-delete-btn {
  color: #ef5350;
}

body.dark-mode .nw-delete-btn:hover {
  background-color: rgba(239, 83, 80, 0.08);
}

body.dark-mode .nw-success-message {
  background-color: rgba(46, 125, 50, 0.1);
  color: #66bb6a;
}

body.dark-mode .nw-error-message {
  background-color: rgba(211, 47, 47, 0.1);
  color: #ef5350;
}

body.dark-mode .nw-info-message {
  background-color: rgba(25, 118, 210, 0.1);
  color: #42a5f5;
}

body.dark-mode .nw-autocomplete-container {
  background: #2c2c2e;
  border-color: rgba(255, 255, 255, 0.2);
}

body.dark-mode .nw-suggestion-item:hover,
body.dark-mode .nw-suggestion-item.active {
  background-color: #3a3a3c;
}

body.dark-mode .nw-suggestion-item strong {
  color: #DDA15E;
}

/* Zero value indicators in dark mode */
body.dark-mode .nw-table tr.nw-zero-value {
  opacity: 0.6;
}

body.dark-mode .nw-table tr.nw-zero-value .nw-value-cell {
  color: rgba(255, 255, 255, 0.4);
}


/* Add this to your dark mode section in networth.js.html */
body.dark-mode .nw-table td {
  border-bottom: 1px solid rgba(255, 255, 255, 0.08);
}

body.dark-mode .nw-table th {
  border-bottom: 1px solid rgba(255, 255, 255, 0.15);
}

/* Dark mode for asset details modal */
body.dark-mode .nw-asset-modal .nw-modal-content {
  background-color: var(--dark-popup-bg, #1e1e1e);
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
}

body.dark-mode .nw-asset-modal .nw-modal-header {
  border-bottom-color: rgba(255, 255, 255, 0.12);
}

body.dark-mode .nw-asset-modal .nw-modal-header h3,
body.dark-mode .nw-asset-modal .nw-field-group label,
body.dark-mode .nw-asset-modal .nw-form-group label,
body.dark-mode .nw-asset-modal .nw-simple-row label {
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
}

body.dark-mode .nw-asset-modal .nw-modal-close {
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
}

body.dark-mode .nw-asset-modal .nw-modal-close:hover {
  background-color: rgba(255, 255, 255, 0.08);
}

body.dark-mode .nw-asset-modal .nw-form-input,
body.dark-mode .nw-asset-modal .nw-form-select,
body.dark-mode .nw-asset-modal .nw-form-textarea,
body.dark-mode .nw-asset-modal .nw-edit-input {
  background-color: #2a2a2a;
  color: var(--dark-text-primary, rgba(255, 255, 255, 0.87));
  border-color: rgba(255, 255, 255, 0.15);
}

body.dark-mode .nw-asset-modal .nw-form-input:focus,
body.dark-mode .nw-asset-modal .nw-form-select:focus,
body.dark-mode .nw-asset-modal .nw-form-textarea:focus,
body.dark-mode .nw-asset-modal .nw-edit-input:focus {
  border-color: #4aa3df;
  box-shadow: 0 0 0 2px rgba(74, 163, 223, 0.25);
}

body.dark-mode .nw-asset-modal .nw-modal-footer {
  background-color: var(--dark-popup-bg, #1e1e1e);
  border-top-color: rgba(255, 255, 255, 0.12);
}

body.dark-mode .nw-asset-modal .nw-modal-chart {
  background-color: #242424;
}

body.dark-mode .nw-asset-modal .nw-goal-section {
  border-top-color: rgba(255, 255, 255, 0.12);
}

body.dark-mode .nw-asset-modal .nw-goal-toggle {
  color: #34d399;
}

body.dark-mode .nw-asset-modal .nw-goal-toggle:hover {
  background-color: rgba(52, 211, 153, 0.1);
}

body.dark-mode .nw-asset-modal .nw-goal-status {
  background-color: rgba(255, 255, 255, 0.08);
}

body.dark-mode .nw-asset-modal .nw-goal-status.achieved {
  background-color: rgba(16, 185, 129, 0.15);
}

body.dark-mode .nw-asset-modal .nw-goal-status.active {
  background-color: rgba(59, 130, 246, 0.15);
}

body.dark-mode .nw-asset-modal .nw-goal-status.expired {
  background-color: rgba(239, 68, 68, 0.15);
}

body.dark-mode .nw-asset-modal .nw-goal-status.upcoming {
  background-color: rgba(107, 114, 128, 0.15);
}

body.dark-mode .nw-asset-modal .nw-goal-progress-row {
  border-top-color: rgba(255, 255, 255, 0.1);
}

body.dark-mode .nw-asset-modal .nw-goal-progress-text {
  color: rgba(255, 255, 255, 0.7);
}

body.dark-mode .nw-asset-modal .nw-goal-progress-percent {
  color: rgba(255, 255, 255, 0.87);
}

body.dark-mode .nw-asset-modal .nw-goal-progress-bar {
  background-color: rgba(255, 255, 255, 0.1);
}

body.dark-mode .nw-asset-modal .nw-goal-clear-btn {
  color: rgba(255, 255, 255, 0.5);
}

body.dark-mode .nw-asset-modal .nw-goal-clear-btn:hover {
  color: #ef4444;
}

body.dark-mode .nw-asset-modal .nw-autocomplete-container {
  background-color: #1f1f1f;
  border-color: rgba(255, 255, 255, 0.15);
  box-shadow: 0 2px 8px rgba(0,0,0,0.4);
}

body.dark-mode .nw-asset-modal .nw-suggestion-item:hover,
body.dark-mode .nw-asset-modal .nw-suggestion-item.active {
  background-color: #2d2d2d;
}

body.dark-mode .nw-modal {
  background-color: var(--dark-popup-bg, #1e1e1e);
}

body.dark-mode .nw-modal-footer {
  background-color: var(--dark-popup-bg, #1e1e1e);
}
/* ======== PRINT STYLES ======== */
@media print {
  .nw-chart-container,
  .nw-section {
    border: 1px solid #ccc;
    break-inside: avoid;
  }
  
  .nw-add-btn,
  .nw-remove-toggle,
  .nw-action-btn,
  .nw-modal-backdrop,
  .nw-modal,
  .nw-timespan-controls,
  .nw-mode-btn,
  .nw-chart-controls {
    display: none;
  }
  
  .nw-editable {
    cursor: text;
  }
  
  .nw-categories-grid {
    grid-template-columns: 1fr 1fr;
  }
  
  .nw-chart-wrapper {
    height: 250px;
  }
}

/* ======== ACCESSIBILITY IMPROVEMENTS ======== */
@media (prefers-reduced-motion: reduce) {
  .nw-btn,
  .nw-action-btn,
  .nw-editable,
  .nw-modal,
  .nw-timespan-btn,
  .nw-mode-btn {
    transition: none;
    animation: none;
  }
}


/* Desktop view - reset any flexbox ordering */
@media (min-width: 769px) {
  #netWorthContent {
    display: block !important; /* Override the flex display for desktop */
    padding-bottom: 50vh; /* Add extra space at bottom to allow scrolling sections to center */
  }

  .nw-chart-container, .nw-message, .nw-categories-grid {
    order: initial !important; /* Reset the order properties */
    margin-top: 10px;
  }
}

/* Mobile view - collapsible chart with summary header */
@media (max-width: 768px) {
  #netWorthContent {
    display: flex !important;
    flex-direction: column !important;
  }

  .nw-chart-container {
    order: -9999 !important;
    margin: 12px !important;
    padding: 0 !important;
    gap: 0 !important;
    display: flex !important;
    flex-direction: column !important;
    width: calc(100% - 24px) !important;
    max-width: none !important;
  }

  .nw-chart-header {
    /* Ensure header is always visible on mobile */
    display: flex !important;
    visibility: visible !important;
    opacity: 1 !important;
    width: 100% !important;
    min-height: 60px !important;
  }

  .nw-chart-content {
    /* Content flows naturally below header */
  }

  .nw-chart-wrapper {
    padding: 15px !important;
  }

  .nw-chart-controls-bar {
    padding: 12px !important;
  }

  .nw-message {
    order: -10000 !important;
  }

  .nw-categories-grid {
    order: 9999 !important;
    margin: 12px !important;
    width: calc(100% - 24px) !important;
    max-width: none !important;
  }
}

/* ======== MODAL STYLES ======== */
.nw-asset-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 10000;
}

.nw-modal-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
}

.nw-modal-content {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  width: 90%;
  max-width: 800px;
  max-height: 84vh;
  overflow-y: auto;
}

.nw-modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px 24px;
  border-bottom: 1px solid #e1e5e9;
}

.nw-modal-header h3 {
  margin: 0;
  font-size: 1.25rem;
  font-weight: 600;
  color: #2c3e50;
}

.nw-modal-close {
  background: none;
  border: none;
  font-size: 24px;
  cursor: pointer;
  padding: 0;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s;
}

.nw-modal-close:hover {
  background-color: #f8f9fa;
}

.nw-modal-body {
  padding: 24px;
}

.nw-modal-form {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.nw-modal-top-row {
  display: grid;
  grid-template-columns: minmax(120px, 0.8fr) minmax(140px, 1fr) minmax(140px, 1.2fr);
  gap: 16px;
  align-items: stretch;
}

.nw-modal-fields-column {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.nw-modal-notes-column {
  display: flex;
  flex-direction: column;
}

.nw-modal-notes-column .nw-form-textarea {
  flex: 1;
  min-height: 80px;
  resize: none;
  width: 100%;
  box-sizing: border-box;
}

.nw-field-group {
  display: flex;
  flex-direction: column;
  gap: 6px;
  position: relative;
}

.nw-field-group label {
  font-weight: 500;
  color: #2c3e50;
  font-size: 0.9rem;
}

.nw-field-group .nw-form-input,
.nw-field-group .nw-form-textarea {
  width: 100%;
  box-sizing: border-box;
}

@media (min-width: 768px) {
  .nw-enhanced-modal .nw-simple-form {
    padding: 0 100px;
  }
}

.nw-modal-chart {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background-color: #f8f9fa;
  border-radius: 8px;
  padding: 8px;
  box-sizing: border-box;
}

.nw-modal-chart.hidden {
  display: none;
}

.nw-modal-top-row:has(.nw-modal-chart.hidden) {
  grid-template-columns: 1fr 1fr;
}

#assetHistoryChart {
  width: 100%;
  max-height: 120px;
}

/* Goal Section - Collapsible */
.nw-goal-section {
  border-top: 1px solid #e1e5e9;
  padding-top: 16px;
  margin-top: 4px;
}

.nw-goal-toggle {
  display: flex;
  align-items: center;
  gap: 8px;
  background: none;
  border: none;
  padding: 8px 12px;
  margin: -8px -12px;
  cursor: pointer;
  font-size: 0.9rem;
  font-weight: 600;
  color: #10b981;
  border-radius: 6px;
  transition: background-color 0.15s;
  width: calc(100% + 24px);
  text-align: left;
}

.nw-goal-toggle:hover {
  background-color: rgba(16, 185, 129, 0.08);
}

.nw-goal-toggle-icon {
  display: inline-block;
  width: 0;
  height: 0;
  border-left: 5px solid currentColor;
  border-top: 4px solid transparent;
  border-bottom: 4px solid transparent;
  transition: transform 0.2s;
}

.nw-goal-section.expanded .nw-goal-toggle-icon {
  transform: rotate(90deg);
}

.nw-goal-content {
  display: none;
  padding-top: 16px;
}

.nw-goal-section.expanded .nw-goal-content {
  display: block;
}

.nw-goal-fields {
  display: grid;
  grid-template-columns: 1.2fr 1fr 1fr 0.8fr;
  gap: 16px;
  align-items: end;
}

.nw-goal-fields .nw-field-group {
  min-width: 0;
}

.nw-goal-status {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 12px;
  border-radius: 6px;
  background-color: #f8f9fa;
  font-weight: 500;
  font-size: 0.85rem;
}

.nw-goal-status-icon {
  font-size: 1rem;
  line-height: 1;
}

.nw-goal-status.achieved {
  background-color: rgba(16, 185, 129, 0.1);
  color: #059669;
}

.nw-goal-status.achieved .nw-goal-status-icon::before {
  content: "✓";
}

.nw-goal-status.active {
  background-color: rgba(59, 130, 246, 0.1);
  color: #2563eb;
}

.nw-goal-status.active .nw-goal-status-icon::before {
  content: "●";
}

.nw-goal-status.expired {
  background-color: rgba(239, 68, 68, 0.1);
  color: #dc2626;
}

.nw-goal-status.expired .nw-goal-status-icon::before {
  content: "✗";
}

.nw-goal-status.upcoming {
  background-color: rgba(107, 114, 128, 0.1);
  color: #6b7280;
}

.nw-goal-status.upcoming .nw-goal-status-icon::before {
  content: "○";
}

.nw-goal-status.none {
  background-color: transparent;
  color: #9ca3af;
}

.nw-goal-status.none .nw-goal-status-icon::before {
  content: "—";
}

/* Goal Progress Row */
.nw-goal-progress-row {
  display: none;
  margin-top: 16px;
  padding-top: 12px;
  border-top: 1px solid #e5e7eb;
}

.nw-goal-progress-row.visible {
  display: block;
}

.nw-goal-progress-info {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 6px;
  font-size: 0.85rem;
}

.nw-goal-progress-text {
  color: #4b5563;
}

.nw-goal-progress-percent {
  font-weight: 600;
  color: #374151;
}

.nw-goal-progress-bar {
  height: 8px;
  background-color: #e5e7eb;
  border-radius: 4px;
  overflow: hidden;
  margin-bottom: 12px;
}

.nw-goal-progress-fill {
  height: 100%;
  border-radius: 4px;
  transition: width 0.3s ease, background-color 0.3s ease;
  background-color: #3b82f6;
}

.nw-goal-progress-fill.achieved {
  background-color: #10b981;
}

.nw-goal-progress-fill.active {
  background-color: #3b82f6;
}

.nw-goal-progress-fill.expired {
  background-color: #ef4444;
}

.nw-goal-progress-fill.upcoming {
  background-color: #9ca3af;
}

.nw-goal-clear-btn {
  background: none;
  border: none;
  color: #9ca3af;
  font-size: 0.8rem;
  cursor: pointer;
  padding: 4px 0;
  transition: color 0.15s;
}

.nw-goal-clear-btn:hover {
  color: #ef4444;
}

@media (max-width: 980px) {
  .nw-modal-top-row {
    grid-template-columns: 1fr 1fr;
  }

  .nw-modal-chart {
    display: none;
  }

  .nw-modal-notes-column .nw-form-textarea {
    min-height: 100px;
  }
}

.nw-autocomplete-container {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  z-index: 1000;
  background: white;
  border: 1px solid #ddd;
  border-top: none;
  border-radius: 0 0 4px 4px;
  max-height: 200px;
  overflow-y: auto;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.nw-input-item {
  position: relative;
}

.nw-simple-form {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.nw-simple-row {
  display: grid;
  grid-template-columns: 100px 1fr;
  gap: 16px;
  align-items: center;
}

.nw-simple-row .nw-amount-input {
  width: 100%;
  min-width: 0; /* Prevents flex item from overflowing */
}

.nw-simple-row label {
  font-weight: 500;
  color: #2c3e50;
  font-size: 0.9rem;
  text-align: left;
}

.nw-amount-input {
  position: relative;
  display: flex !important;
  align-items: center !important;
  min-width: 0; /* Prevents flex container from overflowing its grid area */
}

.nw-currency-symbol {
  position: absolute;
  left: 12px;
  color: #666;
  font-weight: 500;
  pointer-events: none;
  z-index: 1;
}

.nw-amount-input input[type="number"],
.nw-amount-input .nw-form-input {
  padding-left: 28px !important;
}

/* Hide spinner arrows on number inputs */
input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

input[type="number"] {
  -moz-appearance: textfield; /* Firefox */
}


.nw-form-group {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.nw-form-group label {
  font-weight: 500;
  color: #2c3e50;
  font-size: 0.9rem;
}

.nw-form-input,
.nw-form-select,
.nw-form-textarea {
  padding: 8px 12px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 0.9rem;
  transition: border-color 0.2s;
}

.nw-form-input:focus,
.nw-form-select:focus,
.nw-form-textarea:focus {
  outline: none;
  border-color: #3498db;
  box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
}

.nw-form-textarea {
  resize: vertical;
  min-height: 60px;
  width: 200px;
  box-sizing: border-box;
  font-family: inherit;
  line-height: 1.4;
}

.nw-modal-footer {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  padding: 20px 24px;
  border-top: 1px solid #e1e5e9;
  background-color: #f8f9fa;
}

.nw-btn {
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.9rem;
  font-weight: 500;
  transition: all 0.2s;
}

.nw-btn-primary {
  background-color: #27ae60;
  color: white;
}

.nw-btn-primary:hover {
  background-color: #229954;
}

.nw-btn-secondary {
  background-color: #95a5a6;
  color: white;
}

.nw-btn-secondary:hover {
  background-color: #7f8c8d;
}

.nw-btn-danger {
  background-color: #e74c3c;
  color: white;
}

.nw-btn-danger:hover {
  background-color: #c0392b;
}

@media (max-width: 768px) {
  .nw-modal-top-row {
    grid-template-columns: 1fr;
    gap: 16px;
  }

  .nw-modal-fields-column {
    min-width: auto;
  }

  .nw-modal-fields-column .nw-field-group {
    flex-direction: row;
    align-items: center;
    gap: 12px;
  }

  .nw-modal-fields-column .nw-field-group label {
    min-width: 70px;
    margin: 0;
  }

  .nw-modal-fields-column .nw-field-group .nw-form-input,
  .nw-modal-fields-column .nw-field-group .nw-amount-input {
    flex: 1;
  }

  .nw-modal-chart {
    display: none;
  }

  .nw-modal-notes-column .nw-form-textarea {
    min-height: 60px;
  }

  .nw-modal-content {
    width: 95%;
    margin: 20px auto;
  }

  .nw-goal-fields {
    grid-template-columns: 1fr 1fr;
    gap: 12px;
  }

  .nw-goal-fields .nw-field-group label {
    font-size: 0.8rem;
  }

  .nw-goal-status {
    padding: 6px 10px;
    font-size: 0.8rem;
  }
}

@media (max-width: 480px) {
  .nw-goal-fields {
    grid-template-columns: 1fr;
  }
}

</style>
