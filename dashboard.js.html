<script>


// BatchSaveManager - Collects budget changes and saves them in one API call
// Optimistic UI updates happen immediately, server sync is batched

/**
 * BatchSaveManager - Batches multiple budget edits into a single API call
 * - Collects changes as user edits fields
 * - Waits for user to stop editing (2.5s debounce)
 * - Sends all changes in one API call
 * - Retries on failure (up to 3 times)
 * - Reverts UI only on final failure
 */
const BatchSaveManager = (function() {
  // Private state
  let _pendingChanges = {};  // { categoryName: { value, originalValue, element } }
  let _saveTimeout = null;
  let _isSaving = false;
  let _retryCount = 0;
  const MAX_RETRIES = 3;
  const DEBOUNCE_MS = 2500;  // Wait 2.5s after last edit before saving

  /**
   * Build the budget data object with all pending changes
   */
  function buildBudgetData() {
    let budgetData = window.CacheManager.getBudgetData();

    if (!budgetData || !budgetData.budgets) {
      budgetData = { budgets: {}, version: 1 };
    }

    const monthKey = `${_currentYear}-${String(_currentMonth + 1).padStart(2, '0')}`;

    if (!budgetData.budgets[monthKey]) {
      budgetData.budgets[monthKey] = {};
    }

    const currentCategories = window.CacheManager.getCategoriesWithTimestamp();

    // Apply all pending changes
    Object.keys(_pendingChanges).forEach(categoryName => {
      const change = _pendingChanges[categoryName];

      if (categoryName === 'Savings ðŸ’µ') {
        if (change.value > 0) {
          budgetData.budgets[monthKey]['savings'] = change.value;
        } else {
          delete budgetData.budgets[monthKey]['savings'];
        }
      } else {
        if (currentCategories && currentCategories.categories) {
          const category = currentCategories.categories.find(c =>
            c.fullName === categoryName || c.name === categoryName
          );

          if (category && typeof category.order === 'number' && category.order >= 0) {
            if (change.value > 0) {
              budgetData.budgets[monthKey][category.order.toString()] = change.value;
            } else {
              delete budgetData.budgets[monthKey][category.order.toString()];
            }
          }
        }
      }
    });

    return budgetData;
  }

  /**
   * Execute the batch save to server
   */
  function executeSave() {
    if (Object.keys(_pendingChanges).length === 0) {
      _isSaving = false;
      return;
    }

    _isSaving = true;
    const budgetData = buildBudgetData();
    const changesToSave = { ..._pendingChanges };  // Snapshot of what we're saving

    API.saveBudgetData(
      budgetData,
      (result) => {
        // Success - update cache and clear pending
        window.CacheManager.setBudgetData(budgetData);

        // Mark saved fields with brief success indicator
        Object.values(changesToSave).forEach(change => {
          if (change.element) {
            change.element.classList.remove('saving');
            change.element.classList.add('saved');
            setTimeout(() => change.element.classList.remove('saved'), 1000);
          }
        });

        // Clear saved changes from pending (but keep any new ones added during save)
        Object.keys(changesToSave).forEach(key => {
          if (_pendingChanges[key] && _pendingChanges[key].value === changesToSave[key].value) {
            delete _pendingChanges[key];
          }
        });

        _retryCount = 0;
        _isSaving = false;

        // If more changes came in during save, schedule another save
        if (Object.keys(_pendingChanges).length > 0) {
          scheduleSave();
        }
      },
      (error) => {
        _retryCount++;

        if (_retryCount < MAX_RETRIES) {
          // Silent retry after 1 second
          console.log(`Budget save failed, retrying (${_retryCount}/${MAX_RETRIES})...`);
          setTimeout(executeSave, 1000);
        } else {
          // Final failure - revert UI and show error
          console.error('Budget save failed after retries:', error);

          Object.values(changesToSave).forEach(change => {
            if (change.element) {
              change.element.classList.remove('saving');
              change.element.classList.add('error');
              // Revert to original value
              change.element.textContent = Utils.formatCurrency(change.originalValue);
              change.element.dataset.value = change.originalValue;

              // Also revert the progress bar
              if (typeof SimBudget.updateProgressBar === 'function') {
                SimBudget.updateProgressBar(change.categoryName, change.originalValue);
              }

              setTimeout(() => change.element.classList.remove('error'), 2000);
            }
          });

          // Update the info message with reverted values
          if (typeof SimBudget.updateInfoMessage === 'function') {
            SimBudget.updateInfoMessage(true);
          }

          Utils.showToast('Couldn\'t save budget changes. Please try again.', 'error');

          // Clear failed changes
          Object.keys(changesToSave).forEach(key => delete _pendingChanges[key]);
          _retryCount = 0;
          _isSaving = false;
        }
      }
    );
  }

  /**
   * Schedule a save after debounce period
   */
  function scheduleSave() {
    if (_saveTimeout) {
      clearTimeout(_saveTimeout);
    }

    _saveTimeout = setTimeout(() => {
      _saveTimeout = null;
      executeSave();
    }, DEBOUNCE_MS);
  }

  // Public API
  return {
    /**
     * Add a budget change to the batch
     * @param {string} categoryName - Category being changed
     * @param {number} newValue - New budget value
     * @param {number} originalValue - Original value (for revert on failure)
     * @param {HTMLElement} element - The DOM element (for visual feedback)
     */
    addChange: function(categoryName, newValue, originalValue, element) {
      // Store the change (overwrites previous change to same category)
      _pendingChanges[categoryName] = {
        value: newValue,
        originalValue: _pendingChanges[categoryName]?.originalValue ?? originalValue,
        element: element,
        categoryName: categoryName
      };

      // Mark element as pending save
      if (element) {
        element.classList.add('saving');
      }

      // Schedule the batch save
      scheduleSave();
    },

    /**
     * Cancel pending change for a category (e.g., on Escape)
     */
    cancelChange: function(categoryName) {
      delete _pendingChanges[categoryName];
    },

    /**
     * Check if there are unsaved changes
     */
    hasPendingChanges: function() {
      return Object.keys(_pendingChanges).length > 0 || _isSaving;
    },

    /**
     * Force immediate save (e.g., before page unload)
     */
    flush: function() {
      if (_saveTimeout) {
        clearTimeout(_saveTimeout);
        _saveTimeout = null;
      }
      if (Object.keys(_pendingChanges).length > 0 && !_isSaving) {
        executeSave();
      }
    }
  };
})();

// Flush pending saves before page unload
window.addEventListener('beforeunload', function(e) {
  if (BatchSaveManager.hasPendingChanges()) {
    BatchSaveManager.flush();
  }
});

// Legacy alias for any code still referencing SaveQueue
const SaveQueue = {
  add: function(categoryName, value, onSuccess, onError) {
    BatchSaveManager.addChange(categoryName, value, value, null);
  },
  cancelCategory: function(categoryName) {
    BatchSaveManager.cancelChange(categoryName);
  },
  hasPendingSaves: function() {
    return BatchSaveManager.hasPendingChanges();
  }
};


/**
 * Budget Dashboard JavaScript - Render functions for the 3-column dashboard
 */

// Extend the SimBudget namespace with dashboard-specific functions
(function() {

  // Get emoji from category name
  function getEmoji(categoryName) {
    const match = categoryName.match(/\p{Emoji}/u);
    return match ? match[0] : 'ðŸ“Š';
  }
  
  // Get color from category name
    // Replace the getEmoji 
    function getEmoji(categoryName) {
      const emojiRegex = /^[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F700}-\u{1F77F}]|[\u{1F780}-\u{1F7FF}]|[\u{1F800}-\u{1F8FF}]|[\u{1F900}-\u{1F9FF}]|[\u{1FA00}-\u{1FA6F}]|[\u{1FA70}-\u{1FAFF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]|[\u{2300}-\u{23FF}]|[\u{2B00}-\u{2BFF}]|[\u{25A0}-\u{25FF}]|[\u{2190}-\u{21FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{3030}]|[\u{303D}]|[\u{3297}]|[\u{3299}]|[\u{24C2}]|[\u{1F004}]|[\u{1F0CF}]|[\u{1F18E}]$/u;
      
      const match = categoryName.match(emojiRegex);
      return match ? match[0] : 'ðŸ“Š';
    }
  
    // Render the budget dashboard
  /**
   * Render the budget dashboard with modular data
   * @param {Object} data - Combined dashboard data from all modules
   */
  SimBudget.renderBudgetDashboard = function(data) {


    
  // Store categories for reference
  if (data.categories) {
    SimBudget._currentBudgetData = {
      categories: data.categories,
      income: data.summary ? data.summary.income : 0
    };
  }
  
  try {
    // 1. RENDER HEADER (MONTH & YEAR)
    if (data.header) {
      const monthSelector = document.getElementById('monthSelector');
      const yearSelector = document.getElementById('yearSelector');
      
      // Set values without triggering change events
      // Values are updated directly - event handlers are already detached by loadBudgetData
      if (monthSelector && data.header.month) {
        monthSelector.value = data.header.month;
      }
      
      if (yearSelector && data.header.year) {
        yearSelector.value = data.header.year.toString();
      }
    }
    
    // 2. RENDER FINANCIAL SUMMARY
    if (data.summary) {
    const incomeElement = document.getElementById('income-value');
    const spentElement = document.getElementById('spent-value');
    const leftToSpendElement = document.getElementById('left-to-spend-value');
    
        // FIND this section around lines 215-225:
    if (incomeElement) incomeElement.textContent = Utils.formatCurrency(data.summary.income || 0);
    if (spentElement) spentElement.textContent = Utils.formatCurrency(data.summary.spent || 0);
    if (leftToSpendElement) leftToSpendElement.textContent = Utils.formatCurrency(data.summary.leftToSpend || 0);
    
    // REPLACE with this dynamic logic:
    if (incomeElement) incomeElement.textContent = Utils.formatCurrency(data.summary.income || 0);
    if (spentElement) spentElement.textContent = Utils.formatCurrency(data.summary.spent || 0);
    
    // Dynamic left to spend/saved/overspent display
    if (leftToSpendElement) {
      const leftToSpendLabel = document.getElementById('left-to-spend-label');
      
      if (data.summary.displayType === 'leftToSpend') {
        if (leftToSpendLabel) {
          const label = Utils.translateCategory('left_to_spend');
          leftToSpendLabel.textContent = (label && label !== 'left_to_spend') ? label : 'Left to Spend';
        }
        leftToSpendElement.textContent = Utils.formatCurrency(data.summary.leftToSpend || 0);
      } else if (data.summary.displayType === 'saved') {
        if (leftToSpendLabel) leftToSpendLabel.textContent = Utils.translateCategory('saved') || 'Saved';
        leftToSpendElement.textContent = Utils.formatCurrency(data.summary.saved || 0);
      } else if (data.summary.displayType === 'overspent') {
        if (leftToSpendLabel) leftToSpendLabel.textContent = Utils.translateCategory('overspent') || 'Overspent';
        leftToSpendElement.textContent = Utils.formatCurrency(data.summary.overspent || 0);
      } else {
        // Fallback to original behavior
        if (leftToSpendLabel) {
          const label = Utils.translateCategory('left_to_spend');
          leftToSpendLabel.textContent = (label && label !== 'left_to_spend') ? label : 'Left to Spend';
        }
        leftToSpendElement.textContent = Utils.formatCurrency(data.summary.leftToSpend || 0);
      }
    }
      
      // Update budget alert
     const budgetAlert = document.getElementById('budget-alert');
if (budgetAlert) {
  // Don't set textContent directly - let updateInfoMessage handle it
  // Just call updateInfoMessage which will properly set data-translate
  if (typeof SimBudget.updateInfoMessage === 'function') {
    SimBudget.updateInfoMessage(true);
        }
       }
     }   

    
    // 4. RENDER CATEGORIES
    if (data.categories && data.categories.length > 0) {
      const categoriesBody = document.getElementById('budget-categories-body');
      if (categoriesBody) {
        categoriesBody.innerHTML = '';

        // Filter out savings category - it now has its own card
        const expenseCategories = data.categories.filter(c =>
          !c.name.includes('Savings') && c.name !== 'Savings ðŸ’µ'
        );

        expenseCategories.forEach((category, index) =>  {
        const percentSpent = category.budgeted > 0 ? (category.actual / category.budgeted) * 100 : (category.actual > 0 ? 100 : 0);
// Expenses logic
let progressClass = percentSpent > 100 ? 'over-budget' : (percentSpent > 80 ? 'near-limit' : '');        

// Extract emoji and text separately
const emojiRegex = /[\u{1F300}-\u{1F5FF}\u{1F600}-\u{1F64F}\u{1F680}-\u{1F6FF}\u{1F700}-\u{1F77F}\u{1F780}-\u{1F7FF}\u{1F800}-\u{1F8FF}\u{1F900}-\u{1F9FF}\u{1FA00}-\u{1FA6F}\u{1FA70}-\u{1FAFF}\u{2190}-\u{21FF}\u{2300}-\u{23FF}\u{2460}-\u{24FF}\u{2500}-\u{257F}\u{2580}-\u{259F}\u{25A0}-\u{25FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}\u{2B50}\u{2B55}\u{231A}\u{231B}\u{2328}\u{23CF}\u{23E9}-\u{23F3}\u{23F8}-\u{23FA}\u{24C2}\u{25AA}\u{25AB}\u{25B6}\u{25C0}\u{25FB}-\u{25FE}\u{2934}\u{2935}\u{3030}\u{303D}\u{3297}\u{3299}]|\u{FE0F}/gu;

const allEmojis = category.name.match(emojiRegex);
const categoryText = category.name.replace(emojiRegex, '').trim();
const categoryEmoji = allEmojis ? allEmojis.join('') : '';

// Create row
const row = document.createElement('tr');
row.innerHTML = `
  <td class="category-name">
    ${categoryEmoji ? `<span class="category-emoji">${categoryEmoji}</span>` : ''}
    ${Utils.translateCategory(categoryText)}
  </td>
  <td class="budget-value" data-category="${category.name}" data-value="${category.budgeted}">${Utils.formatCurrency(category.budgeted)}</td>
  <td class="actual-value">${Utils.formatCurrency(category.actual)}</td>
  <td class="progress-cell">
    <div class="progress-bar-container">
      <div class="progress-bar ${progressClass}" style="width: ${Math.min(percentSpent, 100)}%"></div>
    </div>
    <div class="progress-percentage">${Math.round(percentSpent)}%</div>
  </td>
`;
  
  categoriesBody.appendChild(row);
});
        
        // Make budget values editable in the next animation frame
        window.requestAnimationFrame(function() {
          if (typeof SimBudget.makeEditableBudgetValues === 'function') {
            try {
              SimBudget.makeEditableBudgetValues();
            } catch (error) {
              console.error("Error making budget values editable:", error);
            }
          }
        });
      }
    }
    
    // 5. RENDER SUBSCRIPTIONS
if (data.subscriptions) {
  try {
    // 5.1 Update subscription summary
    const subscriptionInfo = document.querySelector('.subscription-info');
if (subscriptionInfo) {
  // Get subscription data
  const count = data.subscriptions.count || 0;
  const total = data.subscriptions.total || 0;
  const income = data.summary ? data.summary.income : 0;
  
  // Calculate percentage of income (if income exists)
  let percentText = '';
    if (income > 0) {
      const percentage = Math.round((total / income) * 100);
      percentText = ` - ${percentage}% ${Utils.translateCategory('of Income')}`;
    }
  
  // Build HTML with two separate divs
 const formattedSummary = `
  <div>${Utils.translateCategory('Fixed Payments')}</div>
`;
  
  // Update the element
  subscriptionInfo.innerHTML = formattedSummary;
}
    
    // 5.2 Render subscription list - ADD THIS SECTION
    // 5.2 Render subscription list
const subscriptionBody = document.getElementById('subscription-list-body');
if (subscriptionBody) {
  subscriptionBody.innerHTML = '';
  
  if (data.subscriptions.items && data.subscriptions.items.length > 0) {
    // Find the next payment date (earliest upcoming in current month only)
    let nextPaymentDate = null;
    let earliestDaysDiff = Number.MAX_VALUE;

    // First pass: determine the next payment date (only within current month)
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    data.subscriptions.items.forEach(subscription => {
      if (subscription.nextDate) {
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const [monthStr, dayStr] = subscription.nextDate.split(' ');
        const month = monthNames.indexOf(monthStr);
        const day = parseInt(dayStr);

        if (month !== -1 && !isNaN(day)) {
          const nextDate = new Date(today.getFullYear(), month, day);

          // If date is in the past, assume it's next year
          if (nextDate < today) {
            nextDate.setFullYear(today.getFullYear() + 1);
          }

          const daysDiff = Math.ceil((nextDate - today) / (1000 * 60 * 60 * 24));

          // Only consider payments in the current month for "next payment" highlighting
          const isCurrentMonth = nextDate.getMonth() === today.getMonth() &&
                                 nextDate.getFullYear() === today.getFullYear();

          if (isCurrentMonth && daysDiff >= 0 && daysDiff < earliestDaysDiff) {
            earliestDaysDiff = daysDiff;
            nextPaymentDate = nextDate;
          }
        }
      }
    });
    
    // Second pass: render with proper highlighting
    data.subscriptions.items.forEach(subscription => {
      const row = document.createElement('tr');
      let indicatorContent = '';

      if (subscription.nextDate) {
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const [monthStr, dayStr] = subscription.nextDate.split(' ');
        const month = monthNames.indexOf(monthStr);
        const day = parseInt(dayStr);

        if (month !== -1 && !isNaN(day)) {
  const nextDate = new Date(today.getFullYear(), month, day);

  // If date is in the past, assume it's next year
  if (nextDate < today) {
    nextDate.setFullYear(today.getFullYear() + 1);
  }

  const daysDiff = Math.ceil((nextDate - today) / (1000 * 60 * 60 * 24));

  // Only apply highlighting if the date is in the current month
  const isCurrentMonth = nextDate.getMonth() === today.getMonth() &&
                         nextDate.getFullYear() === today.getFullYear();

  if (isCurrentMonth) {
    // Add class for highlighting
    if (daysDiff === 0) {
      row.classList.add('due-today');
    } else if (daysDiff > 0 && daysDiff <= 3) {
      row.classList.add('due-soon');
    }

    // Add next-payment class and arrow ONLY if this is the next upcoming payment AND it's in current month
    if (nextPaymentDate && nextDate.getTime() === nextPaymentDate.getTime()) {
      row.classList.add('next-payment');
      indicatorContent = 'âŸ«';
    }
  }
}
      }
      
      row.innerHTML = `
        <td class="indicator-column">${indicatorContent}</td>
        <td>${subscription.name || ''}</td>
        <td class="amount-column">${Utils.formatCurrency(subscription.amount)}</td>
        <td class="date-column">${subscription.nextDate || ''}</td>
        <td class="end-spacer"></td>
      `;
      subscriptionBody.appendChild(row);
    });
  }
}
  } catch (subError) {
    console.error("Error rendering subscriptions:", subError);
  }
}

    // 6. RENDER SAVINGS CARD
    if (data.summary && data.categories) {
      try {
        updateSavingsCard(data);
        makeSavingsGoalEditable();
      } catch (savingsError) {
        console.error("Error rendering savings card:", savingsError);
      }
    }

    // 7. RENDER CHART (After small delay to ensure DOM is ready)
setTimeout(function() {
  try {
    if (typeof SimBudget.renderExpenseChart === 'function' && data.categories) {
      SimBudget.renderExpenseChart(data.categories);
    }
    
    // Reorder elements for mobile view
    SimBudget.reorderDashboardForMobile();
    
  } catch (chartError) {
    console.error("Error rendering expense chart:", chartError);
  }
}, 500);
    
  } catch (error) {
    console.error("Error rendering budget dashboard:", error);
  }

  if (typeof completeDashboardRefreshIfPending === 'function') {
    completeDashboardRefreshIfPending();
  }

  if (window._eventManager && typeof _eventManager.attach === 'function') {
    _eventManager.attach();
  }
};


/**
 * Updates the progress bar for a budget category immediately
 * @param {string} categoryName - The category to update
 * @param {number} newBudgetValue - The new budget value
 */
SimBudget.updateProgressBar = function(categoryName, newBudgetValue) {
  // Find the row by matching data-category attribute on budget-value cell
  const rows = document.querySelectorAll('.budget-table tr');
  rows.forEach(row => {
    const budgetCell = row.querySelector('.budget-value');
    if (budgetCell && budgetCell.dataset.category === categoryName) {
      // Get the actual value
      const actualCell = row.querySelector('.actual-value');
      const actualValue = actualCell ? parseFloat(actualCell.textContent.replace(/[^0-9.-]+/g, '')) || 0 : 0;
      
      // Calculate new percentage
      const newPercentage = newBudgetValue > 0 ? (actualValue / newBudgetValue) * 100 : (actualValue > 0 ? 100 : 0);
      const progressClass = newPercentage > 100 ? 'over-budget' : (newPercentage > 80 ? 'near-limit' : '');
      
      // Update progress bar
      const progressBar = row.querySelector('.progress-bar');
      if (progressBar) {
        progressBar.style.width = Math.min(newPercentage, 100) + '%';
        
        // Update classes for color
        progressBar.classList.remove('over-budget', 'near-limit');
        if (progressClass) {
          progressBar.classList.add(progressClass);
        }
      }
      
      // Update percentage text
      const percentageText = row.querySelector('.progress-percentage');
      if (percentageText) {
        percentageText.textContent = Math.round(newPercentage) + '%';
      }
    }
  });
  
  // After updating progress bars, also update the chart
  if (SimBudget._currentBudgetData && SimBudget._currentBudgetData.categories) {
    // Update the category data in memory
    SimBudget._currentBudgetData.categories.forEach(cat => {
      if (cat.name === categoryName) {
        cat.budgeted = newBudgetValue;
      }
    });
    
    // Force redraw the chart
    if (typeof SimBudget.renderExpenseChart === 'function') {
      // Ensure any existing chart is destroyed first
      if (SimBudget._expenseChart) {
        SimBudget._expenseChart.destroy();
        SimBudget._expenseChart = null;
      }
      // Render the chart with updated data
      setTimeout(() => SimBudget.renderExpenseChart(SimBudget._currentBudgetData.categories), 50);
    }
  }
};
 
// Simplified budget editing with BatchSaveManager
// - UI updates immediately on input (optimistic)
// - Save queued on blur
// - BatchSaveManager batches all changes and sends one API call
SimBudget.makeEditableBudgetValues = function() {
  document.querySelectorAll('.budget-value').forEach(cell => {
    cell.setAttribute('contenteditable', 'true');
    cell.setAttribute('title', 'Click to edit budget amount');
    cell.setAttribute('inputmode', 'decimal');
    cell.classList.add('editable');

    const categoryName = cell.dataset.category;
    const originalValue = parseFloat(cell.dataset.value);
    let lastCommittedValue = originalValue;

    // Handle key presses
    cell.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        this.blur();
      }

      if (e.key === 'Escape') {
        e.preventDefault();
        // Revert to last committed value
        this.textContent = Utils.formatCurrency(lastCommittedValue);
        this.dataset.value = lastCommittedValue;
        SimBudget.updateProgressBar(categoryName, lastCommittedValue);
        BatchSaveManager.cancelChange(categoryName);
        this.blur();
      }
    });

    // Update UI immediately on input (optimistic)
    cell.addEventListener('input', function(e) {
      const rawValue = this.textContent.replace(/[^0-9.-]+/g, '');
      const numValue = parseFloat(rawValue);

      if (isNaN(numValue)) return;

      this.classList.add('editing');

      // Update progress bar and chart immediately
      SimBudget.updateProgressBar(categoryName, numValue);

      // Update in-memory data immediately
      if (SimBudget._currentBudgetData && SimBudget._currentBudgetData.categories) {
        SimBudget._currentBudgetData.categories.forEach(cat => {
          if (cat.name === categoryName) {
            cat.budgeted = numValue;
          }
        });
      }

      // Update info message immediately
      if (typeof SimBudget.updateInfoMessage === 'function') {
        SimBudget.updateInfoMessage(true);
      }
    });

    // Commit value on blur - add to batch
    cell.addEventListener('blur', function() {
      const rawValue = this.textContent.replace(/[^0-9.-]+/g, '');
      const numValue = parseFloat(rawValue);

      this.classList.remove('editing');

      if (isNaN(numValue)) {
        // Invalid - revert
        this.textContent = Utils.formatCurrency(lastCommittedValue);
        return;
      }

      // Format display
      this.textContent = Utils.formatCurrency(numValue);
      this.dataset.value = numValue;

      // Skip if unchanged
      if (Math.abs(numValue - lastCommittedValue) < 0.001) {
        return;
      }

      // Add to batch save (will be sent after 2.5s of no edits)
      BatchSaveManager.addChange(categoryName, numValue, lastCommittedValue, this);

      // Update last committed value for this session
      lastCommittedValue = numValue;

      // Update cached data
      if (window._dataCache && window._dataCache.budget && window._dataCache.budget.budget) {
        window._dataCache.budget.budget.categories.forEach(cat => {
          if (cat.name === categoryName) {
            cat.budgeted = numValue;
          }
        });
      }

      if (window.CacheManager) {
        window.CacheManager.invalidate('dashboardData');
      }
    });

    // On focus: select only the number part (after currency symbol)
    cell.addEventListener('focus', function() {
      const text = this.textContent;
      // Find where the number starts (skip currency symbol and spaces)
      const match = text.match(/[\d.,]/);
      if (match) {
        const numberStart = text.indexOf(match[0]);
        const range = document.createRange();
        const textNode = this.firstChild;
        if (textNode) {
          range.setStart(textNode, numberStart);
          range.setEnd(textNode, text.length);
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);
        }
      }
    });

    // Prevent cursor from going before currency symbol
    cell.addEventListener('keydown', function(e) {
      // Already handled Enter and Escape above, but those handlers return early
      // This handles arrow keys and backspace at the start
      const selection = window.getSelection();
      if (!selection.rangeCount) return;

      const range = selection.getRangeAt(0);
      const text = this.textContent;
      const match = text.match(/[\d.,]/);
      const numberStart = match ? text.indexOf(match[0]) : 0;

      // Prevent backspace from deleting currency symbol
      if (e.key === 'Backspace' && range.startOffset <= numberStart && range.collapsed) {
        e.preventDefault();
      }

      // Prevent left arrow from going before currency symbol
      if (e.key === 'ArrowLeft' && range.startOffset <= numberStart && range.collapsed) {
        e.preventDefault();
      }
    });

    // Prevent selecting/deleting currency symbol
    cell.addEventListener('mouseup', function() {
      const selection = window.getSelection();
      if (!selection.rangeCount) return;

      const range = selection.getRangeAt(0);
      const text = this.textContent;
      const match = text.match(/[\d.,]/);
      const numberStart = match ? text.indexOf(match[0]) : 0;

      // If selection starts before number, move it to number start
      if (range.startOffset < numberStart) {
        const textNode = this.firstChild;
        if (textNode) {
          range.setStart(textNode, numberStart);
          selection.removeAllRanges();
          selection.addRange(range);
        }
      }
    });
  });
};


/**
 * Minimal implementation of expense chart to prevent errors
 * @param {Array} categories - Budget categories data
 */
SimBudget.renderExpenseChart = function(categories) {
  const canvas = document.getElementById('expense-donut-chart');
  if (!canvas) return;
  
  // Check if Chart.js is available
  if (typeof Chart === 'undefined') {
    console.log("Chart.js not available, skipping chart render");
    return;
  }
  
  // Clear any existing chart
  if (SimBudget._expenseChart) {
    SimBudget._expenseChart.destroy();
  }
  
  // Predefined palette of 30 matte colors
  const colorPalette = [
    '#fd7f6f', '#7eb0d5', '#b2e061', '#bd7ebe', '#ffb55a', '#ffee65',
    '#beb9db', '#fdcce5', '#8bd3c7', '#a5cfb5', '#89c7a3', '#6bbf91',
    '#ffadad', '#ffd6a5', '#fdffb6', '#caffbf', '#9bf6ff', '#a0c4ff',
    '#bdb2ff', '#ffc6ff', '#fffffc', '#d0f4de', '#fefae0', '#f1c0e8',
    '#51a6f8', '#3a8ded', '#ff9f70', '#ffb685', '#ffd6a5', '#ffe8b3'
  ];
  
  // Get data for chart and assign colors from palette
  const chartData = categories
    .filter(cat => cat.actual > 0)
      .filter(cat => !cat.name.toLowerCase().includes('savings')) // â† ADD THIS LINE!

    .map((cat, index) => {
      // Extract emoji from category name
      const emoji = getEmoji(cat.name);
      
      return {
        label: cat.name,
        value: cat.actual,
        color: colorPalette[index % colorPalette.length],
        emoji: emoji // Store the emoji for later use
      };
    });
  
  if (chartData.length === 0) return;
  
  // Calculate total budget for percentages
  const totalBudget = chartData.reduce((sum, item) => sum + item.value, 0);
  
  // Create custom plugin to draw emojis on chart segments
  // Create custom plugin to draw emojis on chart segments
const emojiPlugin = {
  id: 'emojiPlugin',
  afterDraw: function(chart) {
    const ctx = chart.ctx;
    const meta = chart.getDatasetMeta(0);
    
    // For each segment
    meta.data.forEach((element, index) => {
      // Get the emoji for this segment
      let emoji = chartData[index].emoji;
      if (!emoji || emoji === 'ðŸ“Š') return; // Skip if no emoji or default
      
      // FUTURE-PROOF FIX: Ensure emoji presentation for ALL emojis
      // This adds the variation selector if it's not already there
      if (!emoji.includes('\uFE0F')) {
        emoji = emoji + '\uFE0F';
      }
      
      // Calculate the percentage of this segment
      const percentage = chartData[index].value / totalBudget;
      
      // Only draw emoji if segment is large enough (at least 4% of total)
      if (percentage >= 0.04) {
        // Get segment center and radius
        const centerX = element.x;
        const centerY = element.y;
        const radius = element.outerRadius;
        const innerRadius = element.innerRadius;
        
        // Calculate position to place emoji (middle of the segment)
        const midRadius = innerRadius + (radius - innerRadius) * 0.5;
        const startAngle = element.startAngle;
        const endAngle = element.endAngle;
        const midAngle = startAngle + (endAngle - startAngle) / 2;
        
        // Position emoji at midpoint of the segment
        const x = centerX + Math.cos(midAngle) * midRadius;
        const y = centerY + Math.sin(midAngle) * midRadius;
        
        // Set the font size proportional to the segment size - smaller for denser labeling
        const arcSize = radius * (endAngle - startAngle);
        const fontSize = Math.min(Math.max(arcSize * 0.32, 10), 26);
        
        // Draw the emoji with better font support
        ctx.font = `${fontSize}px Arial, "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(emoji, x, y);
      }
    });
  }
};
  
  // Create simple chart
  const ctx = canvas.getContext('2d');
  SimBudget._expenseChart = new Chart(ctx, {
    type: 'doughnut',
    data: {
      labels: chartData.map(item => item.label),
      datasets: [{
        data: chartData.map(item => item.value),
        backgroundColor: chartData.map(item => item.color),
        borderWidth: 1,
        borderColor: '#ffffff'
      }]
    },
    options: {
  responsive: true,
  maintainAspectRatio: false,
  cutout: '70%', // Slightly larger hole for better donut look
  plugins: {
    legend: {
      display: false // Hide the legend completely as requested
    },
    tooltip: {
      // Add this to ensure tooltip appears in front
      position: 'nearest',
      z: 100,
      callbacks: {
        // Customize tooltip - avoid duplicate emojis
        label: function(context) {
          const value = context.raw;
          const percentage = ((value / totalBudget) * 100).toFixed(1);
          const formattedValue = Utils.formatCurrency(value);
          const emoji = chartData[context.dataIndex].emoji;
          
          // Get label without emoji (if it contains the emoji)
          let label = context.label;
          if (label.includes(emoji)) {
            // Remove the emoji from the label
            label = label.replace(emoji, '').trim();
          }
          
          return `${emoji} ${label}: ${formattedValue} (${percentage}%)`;
        }
      },
      backgroundColor: 'rgba(0,0,0,0.8)',
      padding: 12,
      titleFont: {
        size: 14,
        weight: 'bold'
      },
      bodyFont: {
        size: 13
      },
      cornerRadius: 4,
      displayColors: true,
      boxWidth: 12,
      boxHeight: 12,
      boxPadding: 3
    }
  },
  // Add hover effect to make segments pop out slightly
  hover: {
    mode: 'nearest',
    intersect: true
  },
  animation: false,
  // Add this to ensure tooltip is visible
  layout: {
    padding: {
      top: 10,
      bottom: 10,
      left: 10,
      right: 10
    }
  }
},
    plugins: [emojiPlugin] // Add our custom emoji plugin
  });
};


// Add this flag at the top of your IIFE
let _hasReorderedMobile = false;

/**
 * Reorder dashboard elements on mobile devices - fixed non-looping version
 */
SimBudget.reorderDashboardForMobile = function() {
  // Only apply on mobile devices and if not already reordered
  if (window.innerWidth <= 768 && !_hasReorderedMobile) {
    // Set flag to prevent repeated execution
    _hasReorderedMobile = true;
    
    const container = document.querySelector('.dashboard-container') || 
                     document.querySelector('.view-content');
    
    if (!container) return;
    
    // Get all elements (keep your existing selectors)
    const incomeBox = container.querySelector('.income-spent-box, .budget-summary-card');
    const budgetCard = container.querySelector('.dashboard-card.budget-data-card');
    const subscriptionText = container.querySelector('.subscription-header, .subscription-text');
    const subscriptionSummary = container.querySelector('.subscription-summary');
    const chartCard = container.querySelector('.donut-chart-card, .dashboard-card.chart-card');
    
    // Use document fragment for batch DOM operations
    const fragment = document.createDocumentFragment();
    
    // Add elements to fragment in desired order
    if (incomeBox) fragment.appendChild(incomeBox);
    if (budgetCard) fragment.appendChild(budgetCard);
    if (subscriptionText) fragment.appendChild(subscriptionText);
    if (subscriptionSummary) fragment.appendChild(subscriptionSummary);
    if (chartCard) fragment.appendChild(chartCard);
    
    // Append all at once
    container.appendChild(fragment);
    
    if (typeof SimBudget.fixMobileDisplay === 'function') {
      const originalFn = SimBudget.fixMobileDisplay;
      SimBudget.fixMobileDisplay = function() {
        if (window.innerWidth <= 768) {
          document.querySelectorAll('.budget-data-card td, .budget-value, .actual-value, [id$="-value"], .amount, .amount-column')
            .forEach(el => {
              // Existing decimal removal logic
              // ...
            });
        }
      };
      SimBudget.fixMobileDisplay();
      SimBudget.fixMobileDisplay = originalFn; // Restore original
    }
  }
};

// Add this to your window resize handler to reset the flag when needed
window.addEventListener('resize', function() {
  if (window.innerWidth > 768) {
    _hasReorderedMobile = false;
  }
});




/**
 * Clean up mobile display - remove decimals and fix layout
 */
SimBudget.fixMobileDisplay = function() {
  if (window.innerWidth <= 768) {
    
    // 1. Remove decimals from ALL amount values - more aggressive approach
    document.querySelectorAll('.budget-data-card td, .budget-value, .actual-value, [id$="-value"], .amount, .amount-column')
      .forEach(el => {
        // Only process text nodes (not child elements)
        if (el.childNodes && el.childNodes.length) {
          for (let i = 0; i < el.childNodes.length; i++) {
            if (el.childNodes[i].nodeType === 3) { // Text node
              const text = el.childNodes[i].textContent;
              // Remove everything after decimal point
              if (text.includes('.') || text.includes(',')) {
                const parts = text.match(/([^\d]*)([\d,]+)([.,]\d+)?(\D*)/);
                if (parts) {
                  el.childNodes[i].textContent = parts[1] + parts[2] + parts[4];
                }
              }
            }
          }
        }
      });
  }
};




// Keep both the server-save event and add immediate updates
document.addEventListener('transaction-batch-saved', handleTransactionUpdate);



// Monkey patch TransactionManager for immediate updates
if (window.TransactionManager) {
  const originalAdd = TransactionManager.addTransaction;
  const originalUpdate = TransactionManager.updateTransaction;
  
  TransactionManager.addTransaction = function(tx) {
    const result = originalAdd.apply(this, arguments);
    updateBudgetFromSingleTx(tx, true);
    return result;
  };
  
  TransactionManager.updateTransaction = function(tx) {
    const result = originalUpdate.apply(this, arguments);
    updateBudgetFromSingleTx(tx, true);
    return result;
  };
}

// Handle either single transaction or batch from event
function handleTransactionUpdate(event) {
  const transactions = event.detail?.transactions;
  if (!transactions || !Array.isArray(transactions) || transactions.length === 0) return;
  
  // Process each transaction
  transactions.forEach(tx => {
    updateBudgetFromSingleTx(tx);
    
    // ADD THIS: Update CacheManager
    if (window.CacheManager && tx.amount > 0) {
      const month = tx.date ? new Date(tx.date).getMonth() : _currentMonth;
      const year = tx.date ? new Date(tx.date).getFullYear() : _currentYear;
      
      // Update the expense in cache
      CacheManager.updateExpense(tx, month, year);
      
      // Force dashboard recalculation
      CacheManager.invalidate('dashboardData');
    }
  });
}
// Core function to update budget from a transaction
function updateBudgetFromSingleTx(tx, immediate = false) {
  if (!tx || tx.amount <= 0 || tx.deleted) return;
  
  const categoryWithEmoji = tx.emoji ? `${tx.category} ${tx.emoji}` : tx.category;
  
  // SAFE UPDATE: Use cache fix to prevent race conditions
  const updateSuccess = CacheFix.safeUpdate('budget', () => {
    // Update both in-memory data and cache
    updateBudgetData(SimBudget._currentBudgetData, categoryWithEmoji, tx.amount);
    
    // Update the cache safely
    if (window._dataCache?.budget?.budget) {
      updateBudgetData(window._dataCache.budget.budget, categoryWithEmoji, tx.amount);
    }
    
    return true;
  });
  
  if (!updateSuccess) {
    console.warn('Budget update blocked due to concurrent operation');
    return;
  }
  
  // Update UI if needed and we're on budget view
  if (immediate && SimBudget.Views.getCurrent() === 'budget') {
    updateBudgetUI(categoryWithEmoji);
  }
}

// Update budget data structure
function updateBudgetData(budgetData, category, amount) {
  if (!budgetData?.categories) return;
  
  let updated = false;
  
  // Update category actual values
  budgetData.categories.forEach(cat => {
    if (cat.name === category) {
      cat.actual = (cat.actual || 0) + amount;
      updated = true;
    }
  });
  
  // Update summary if needed
  if (updated && budgetData.summary) {
    // Calculate new totals
    const totalSpent = budgetData.categories.reduce((sum, cat) => sum + (cat.actual || 0), 0);
    
    budgetData.summary.spent = totalSpent;
    
    if (budgetData.summary.income !== undefined) {
      budgetData.summary.leftToSpend = budgetData.summary.income - totalSpent;
    }
  }
}

// Update the budget UI
function updateBudgetUI(categoryWithEmoji) {
  if (!SimBudget._currentBudgetData?.categories) return;
  
  // Find the category
  const category = SimBudget._currentBudgetData.categories.find(c => c.name === categoryWithEmoji);
  if (!category) return;
  
  // Update category row
  document.querySelectorAll('.budget-table tr').forEach(row => {
    const categoryCell = row.querySelector('.category-name');
    if (categoryCell?.textContent === categoryWithEmoji) {
      // Update actual value
      const actualCell = row.querySelector('.actual-value');
      if (actualCell) actualCell.textContent = Utils.formatCurrency(category.actual);
      
      // Update progress bar
      const budgetCell = row.querySelector('.budget-value');
      if (budgetCell) {
        const budgetValue = parseFloat(budgetCell.dataset.value || '0');
        const percentage = budgetValue > 0 ? (category.actual / budgetValue) * 100 : (category.actual > 0 ? 100 : 0);
        const progressClass = percentage > 100 ? 'over-budget' : (percentage > 80 ? 'near-limit' : '');
        
        const progressBar = row.querySelector('.progress-bar');
        if (progressBar) {
          progressBar.style.width = Math.min(percentage, 100) + '%';
          progressBar.classList.remove('over-budget', 'near-limit');
          if (progressClass) progressBar.classList.add(progressClass);
        }
        
        const percentageText = row.querySelector('.progress-percentage');
        if (percentageText) percentageText.textContent = Math.round(percentage) + '%';
      }
    }
  });
  
  // Update summary values
  if (SimBudget._currentBudgetData.summary) {
    const spentEl = document.getElementById('spent-value');
    if (spentEl) spentEl.textContent = Utils.formatCurrency(SimBudget._currentBudgetData.summary.spent);
    
    const leftEl = document.getElementById('left-to-spend-value');
    if (leftEl) leftEl.textContent = Utils.formatCurrency(SimBudget._currentBudgetData.summary.leftToSpend);
  }
}



function notifyDashboardOfCategoryChange() {
  if (SimBudget.Views.getCurrent() !== 'budget') {
    return;
  }
  
  // Just re-run the same load process that happens when navigating to budget
  SimBudget.loadBudgetData(true); // Don't force refresh, just reload normally
}

window.notifyDashboardOfCategoryChange = notifyDashboardOfCategoryChange;

/**
 * Update the Savings Card with current data
 *
 * Monthly Savings Logic:
 * - Goal = Budget set for the Savings category
 * - We only show the goal value and month label early in the month
 */
function updateSavingsCard(data) {
  const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                      'July', 'August', 'September', 'October', 'November', 'December'];

  // Get current month name
  const now = new Date();
  const currentMonth = window._currentMonth !== undefined ? window._currentMonth : now.getMonth();
  const currentYear = window._currentYear !== undefined ? window._currentYear : now.getFullYear();
  const isCurrentMonth = currentMonth === now.getMonth() && currentYear === now.getFullYear();

  const goalLabel = document.getElementById('savingsGoalLabel');
  if (goalLabel) {
    if (isCurrentMonth) {
      goalLabel.textContent = `Goal for ${monthNames[currentMonth]} ${currentYear}`;
    } else {
      goalLabel.textContent = `Goal in ${monthNames[currentMonth]} ${currentYear}`;
    }
  }

  // Savings goal = budget set for savings category
  const savingsCategory = (data.categories || []).find(c =>
    c && c.name && (c.name === 'Savings ðŸ’µ' || c.name.includes('Savings'))
  );
  const savingsGoal = savingsCategory ? (savingsCategory.budgeted || 0) : 0;

  // Update monthly savings display (goal-only presentation)
  const monthGoal = document.getElementById('savingsMonthGoal');
  if (monthGoal) {
    const safeGoal = Math.max(0, savingsGoal);
    monthGoal.textContent = Utils.formatCurrency(safeGoal);
    monthGoal.dataset.value = safeGoal;
  }

  const actualRow = document.getElementById('savingsActualRow');
  const outcomeRow = document.getElementById('savingsOutcomeRow');
  const actualLabel = document.getElementById('savingsActualLabel');
  const actualValue = document.getElementById('savingsActualValue');
  const outcomeValue = document.getElementById('savingsOutcomeValue');

  if (!isCurrentMonth) {
    const actualSaved = (data.summary.income || 0) - (data.summary.spent || 0);
    const outcomeDelta = actualSaved - savingsGoal;

    if (actualLabel) {
      actualLabel.textContent = actualSaved >= 0 ? 'Actually saved' : 'Actually overspent';
    }

    if (actualValue) {
      actualValue.textContent = Utils.formatCurrency(Math.abs(actualSaved));
    }

    if (outcomeValue) {
      if (Math.abs(outcomeDelta) < 0.01) {
        outcomeValue.textContent = 'On target';
      } else {
        const direction = outcomeDelta >= 0 ? 'above goal' : 'below goal';
        const sign = outcomeDelta >= 0 ? '+' : '-';
        outcomeValue.textContent = `${sign} ${Utils.formatCurrency(Math.abs(outcomeDelta))} ${direction}`;
      }
    }

    if (actualRow) actualRow.style.display = 'flex';
    if (outcomeRow) outcomeRow.style.display = 'flex';
  } else {
    if (actualRow) actualRow.style.display = 'none';
    if (outcomeRow) outcomeRow.style.display = 'none';
  }

  // Long-term goal (from saved settings)
  const savingsGoals = getSavingsGoals();
  const longtermSection = document.getElementById('savingsLongtermSection');

  if (savingsGoals && savingsGoals.longtermName && savingsGoals.longtermTarget > 0) {
    if (longtermSection) longtermSection.style.display = 'block';

    const goalName = document.getElementById('savingsGoalName');
    const goalActual = document.getElementById('savingsGoalActual');
    const goalTarget = document.getElementById('savingsGoalTarget');
    const goalPercent = document.getElementById('savingsGoalPercent');
    const goalProgress = document.getElementById('savingsGoalProgress');
    const goalDeadline = document.getElementById('savingsGoalDeadline');

    if (goalName) goalName.textContent = savingsGoals.longtermName;
    if (goalTarget) goalTarget.textContent = Utils.formatCurrency(savingsGoals.longtermTarget);

    // Calculate total saved toward long-term goal
    const totalSaved = savingsGoals.longtermSaved || 0;
    if (goalActual) goalActual.textContent = Utils.formatCurrency(totalSaved);

    const ltPercent = Math.round((totalSaved / savingsGoals.longtermTarget) * 100);
    if (goalPercent) goalPercent.textContent = ltPercent + '%';
    if (goalProgress) goalProgress.style.width = Math.min(100, ltPercent) + '%';

    if (goalDeadline && savingsGoals.longtermDeadline) {
      goalDeadline.textContent = savingsGoals.longtermDeadline;
    } else if (goalDeadline) {
      goalDeadline.textContent = '';
    }
  } else {
    if (longtermSection) longtermSection.style.display = 'none';
  }
}

/**
 * Make Savings Goal editable (stored as Savings category budget)
 */
function makeSavingsGoalEditable() {
  const goalEl = document.getElementById('savingsMonthGoal');
  if (!goalEl || goalEl.dataset.editableAttached === 'true') return;

  goalEl.dataset.editableAttached = 'true';
  goalEl.setAttribute('contenteditable', 'true');
  goalEl.setAttribute('title', 'Click to edit savings goal');
  goalEl.setAttribute('inputmode', 'decimal');
  goalEl.classList.add('editable');

  const categoryName = 'Savings ðŸ’µ';
  const originalValue = parseFloat(goalEl.dataset.value || '0');
  let lastCommittedValue = isNaN(originalValue) ? 0 : originalValue;

  goalEl.addEventListener('keydown', function(e) {
    if (e.key === 'Enter') {
      e.preventDefault();
      this.blur();
    }

    if (e.key === 'Escape') {
      e.preventDefault();
      this.textContent = Utils.formatCurrency(lastCommittedValue);
      this.dataset.value = lastCommittedValue;
      BatchSaveManager.cancelChange(categoryName);
      this.blur();
    }
  });

  goalEl.addEventListener('input', function() {
    const rawValue = this.textContent.replace(/[^0-9.-]+/g, '');
    const numValue = parseFloat(rawValue);
    if (isNaN(numValue)) return;

    this.classList.add('editing');

    if (SimBudget._currentBudgetData && Array.isArray(SimBudget._currentBudgetData.categories)) {
      let savingsCat = SimBudget._currentBudgetData.categories.find(c => c.name === categoryName);
      if (!savingsCat) {
        savingsCat = { name: categoryName, budgeted: numValue, actual: 0 };
        SimBudget._currentBudgetData.categories.push(savingsCat);
      } else {
        savingsCat.budgeted = numValue;
      }
    }

    if (typeof SimBudget.updateInfoMessage === 'function') {
      SimBudget.updateInfoMessage(true);
    }
  });

  goalEl.addEventListener('blur', function() {
    const rawValue = this.textContent.replace(/[^0-9.-]+/g, '');
    const numValue = parseFloat(rawValue);

    this.classList.remove('editing');

    if (isNaN(numValue)) {
      this.textContent = Utils.formatCurrency(lastCommittedValue);
      return;
    }

    this.textContent = Utils.formatCurrency(numValue);
    this.dataset.value = numValue;

    if (Math.abs(numValue - lastCommittedValue) < 0.001) {
      return;
    }

    BatchSaveManager.addChange(categoryName, numValue, lastCommittedValue, this);
    lastCommittedValue = numValue;

    if (window._dataCache && window._dataCache.budget && window._dataCache.budget.budget) {
      const cacheCats = window._dataCache.budget.budget.categories || [];
      const cachedSavings = cacheCats.find(c => c.name === categoryName);
      if (cachedSavings) {
        cachedSavings.budgeted = numValue;
      } else {
        cacheCats.push({ name: categoryName, budgeted: numValue, actual: 0 });
      }
      window._dataCache.budget.budget.categories = cacheCats;
    }

    if (window.CacheManager) {
      window.CacheManager.invalidate('dashboardData');
    }
  });

  goalEl.addEventListener('focus', function() {
    const text = this.textContent;
    const match = text.match(/[\d.,]/);
    if (match) {
      const numberStart = text.indexOf(match[0]);
      const range = document.createRange();
      const textNode = this.firstChild;
      if (textNode) {
        range.setStart(textNode, numberStart);
        range.setEnd(textNode, text.length);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
      }
    }
  });
}

/**
 * Get savings goals from storage
 */
function getSavingsGoals() {
  try {
    const stored = localStorage.getItem('simbudget_savings_goals');
    return stored ? JSON.parse(stored) : null;
  } catch (e) {
    console.error('Error reading savings goals:', e);
    return null;
  }
}

/**
 * Save savings goals to storage
 */
function saveSavingsGoals(goals) {
  try {
    localStorage.setItem('simbudget_savings_goals', JSON.stringify(goals));
  } catch (e) {
    console.error('Error saving savings goals:', e);
  }
}

// Expose for settings modal
window.getSavingsGoals = getSavingsGoals;
window.saveSavingsGoals = saveSavingsGoals;
window.updateSavingsCard = updateSavingsCard;
window.makeSavingsGoalEditable = makeSavingsGoalEditable;

})();

</script>
